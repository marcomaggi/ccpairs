\input texinfo.tex
@c %**start of header
@setfilename ccpairs.info
@settitle CCPairs
@c %**end of header

@include version.texi
@include macros.texi

@c page
@c ------------------------------------------------------------
@c Local macros.
@c ------------------------------------------------------------

@macro ccmemoryref{NODE,TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,ccmemory}
@end macro

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      CCPairs

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    CCPairs

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           ccpairs

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{marco.maggi-ipsu@@poste.it}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2017, 2018

@c ------------------------------------------------------------

@set CCEXCEPTIONS_VERSION       0.8.0
@set CCMEMORY_VERSION           0.1.0
@set CCTESTS_VERSION            0.3.0

@c ------------------------------------------------------------

@set GITHUB_URL                 @url{https://github.com/marcomaggi/@value{PACKAGE_NICKNAME}}
@set BITBUCKET_URL              @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}}
@set DOWNLOAD_URL               @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}/downloads}
@set DOCUMENTATION_URL          @url{https://marcomaggi.github.io/docs/@value{PACKAGE_NICKNAME}.html}

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
This document describes version @value{VERSION} of @value{PACKAGE}, a C11 language library
implementing a simply linked lists data structures, in the style of the Scheme language.

The library targets @posix{} platforms.  The library depends on the packages: CCExceptions, at least
version @value{CCEXCEPTIONS_VERSION}; CCMemory, at least version @value{CCMEMORY_VERSION}.  To run
the test suite: the package depends upon the package CCTests, at least version
@value{CCTESTS_VERSION}.

The package is distributed under the terms of the @gnu{} Lesser General Public License (@lgpl{}).

The latest release can be downloaded from:

@center @value{DOWNLOAD_URL}

@noindent
development takes place at:

@center @value{GITHUB_URL}

@noindent
and as backup at:

@center @value{BITBUCKET_URL}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}

@quotation
Permission is granted to copy, distribute and/or modify this document under the terms of the @gnu{}
Free Documentation License, Version 1.3 or any later version published by the Free Software
Foundation; with Invariant Sections being ``@gnu{} Free Documentation License'' and ``@gnu{} General
Public License'', no Front--Cover Texts, and no Back--Cover Texts.  A copy of the license is
included in the section entitled ``@gnu{} Free Documentation License''.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @value{VERSION}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* ccpairs: (ccpairs).           Scheme pairs and lists for C11.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* init::                        Library initialisation.
* version::                     Version functions.
* typedefs::                    Some type definitions.
* pairs::                       Pair data structures.
* memory::                      Memory allocation.
* constructors::                Constructing pairs and lists.
* inspection::                  Inspecting lists.
* accessors::                   Accessing items in lists.
* conditions::                  Exceptional condition objects.
* handlers::                    Exceptional condition handlers.

Appendices

* Package License::             GNU Lesser General Public License.
* Documentation License::       GNU Free Documentation License.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


This document describes version @value{VERSION} of @value{PACKAGE}, a C11 language library
implementing simply linked lists data structures, in the style of the Scheme language.

The library targets @posix{} platforms.  The library depends on the packages: CCExceptions, at least
version @value{CCEXCEPTIONS_VERSION}; CCMemory, at least version @value{CCMEMORY_VERSION}.

@value{PACKAGE} installs the single header file @file{ccpairs.h}.  All the function names in the
@api{} are prefixed with @code{ccpair_}; all the preprocessor symbol names are prefixed with
@code{CCPAIR_}; all the type names are prefixed with @code{ccpair_} and suffixed with @code{_t}.

The library's @api{} uses both @code{inline} functions and preprocessor macros to integrate some
common operations at the call site.

Notice that, before using the library, we need to call the global initialisation function
@cfunc{ccpair_library_init}.

@strong{IMPORTANT} To use the library we must enable the @posix{} features when including the
standard header files; so either we include @file{ccpair.h} as first header, or we include the
following definitions before including @strong{all} the header files:

@example
#define _POSIX_C_SOURCE         200809L
@end example

@menu
* overview linking::            Linking code with the library.
* overview lists::              How lists work.
@end menu

@c page
@node overview linking
@section Linking code with the library


library with the @gnu{} Autotools, we can add the following macro use to @file{configure.ac}:

@example
PKG_CHECK_MODULES([CCPAIRS],[ccpairs >= 0.1])
@end example

@noindent
which will set the variables @code{CCPAIRS_LIBS} and @code{CCPAIRS_CFLAGS}.  To avoid problems with
@command{pkg-config}, we need to remember that:

@itemize
@item
The macro file defining @code{PKG_CHECK_MODULES} is installed by the package @code{pkg-config}; such
file usually is in one of the locations:

@center @file{/usr/share/aclocal/pkg.m4}
@center @file{/usr/local/share/aclocal/pkg.m4}

@item
The macro file is located by @command{aclocal}, which in turn is installed by the package @gnu{}
Automake; @command{aclocal} is used by @command{autoreconf}.  We must make sure that
@command{aclocal} finds the installed macro files; for this purpose we can use the environment
variable @env{ACLOCAL_PATH}; under a Bourne shell we can do this with:

@example
export ACLOCAL_PATH=/usr/local/share/aclocal:/usr/share/aclocal
@end example
@end itemize

Alternatively we can use the raw @gnu{} Autoconf macros:

@example
AC_CHECK_LIB([ccpairs],[cct_version_string],,
  [AC_MSG_FAILURE([test for CCPairs library failed])])
AC_CHECK_HEADERS([ccpairs.h],,
  [AC_MSG_FAILURE([test for CCPairs header failed])])
@end example

@c page
@node overview lists
@section How lists work


@value{PACKAGE} implements simply--linked lists in the style of the Scheme language; Scheme is a
dialect of Lisp.  A well structured, or @dfn{proper}, Scheme list is a chain of ``pairs'', where
each pair is an ordered couple of machine words:

@itemize
@item
The first or left or @dfn{car} machine word is meant to contain the list--node payload--value,
either directly in the machine word or as value referenced by a pointer.

@item
The second or right or @dfn{cdr} machine word is meant to contain a pointer to the next node in the
list, or @cnull{} if there are no more nodes.
@end itemize

Here is an example of list with three pairs, which means that there are three payload items:

@example
 ---------       ---------       ---------
| A1 | D1 | --> | A2 | D2 | --> | A3 | D3 | --> NULL
 ---------       ---------       ---------
   |               |               |
   v               v               v
 value1          value2          value3
@end example

From the point of view of the public @value{PACKAGE} @api{}: pairs are immutable; internally the
functions may mutate the pairs while building a new list.

Immutable pairs mean that it is possible and encouraged to write functions that share the tail of a
list; here is an example of lists layout where two lists share the tail:

@example
 -------       -------       -------       -------
| A | D | --> | A | D | --> | A | D | --> | A | D | --> NULL
 -------       -------       -------       -------
                              ^
 -------       -------        |
| A | D | --> | A | D | ------
 -------       -------
@end example

@noindent
care must be taken if we need to append lists that may share the tail with other lists.

By using the first word of a pair as a pointer to list: we can represent binary trees; here is an
example:

@example
 -------       -------
| A | D | --> | A | D | --> NULL
 -------       -------
  |                 |
  |                 |     -------       -------
  |                  --> | A | D | --> | A | D | --> NULL
  |                       -------       -------
  v
 -------       -------       -------
| A | D | --> | A | D | --> | A | D | --> NULL
 -------       -------       -------
  |
  v
 -------
| A | D | --> NULL
 -------
@end example

@noindent
this works only if we use some sort of tagging in the first words to distinguish a pointer to pair
from a payload value.

Unless otherwise specified: the functions of this library @strong{do not} work with circular lists.
A circular list looks as follows:

@example
 -------       -------       -------       -------
| A | D | --> | A | D | --> | A | D | --> | A | D |
 -------       -------       -------       -------
                ^                               |
                |                               |
                 -------------------------------
@end example

@noindent
It is generally a bad idea to create circular lists; if we need them: we should mimic an actually
circular chain of pointers with an iterator that ``wraps around''.

It is sometimes useful to crate a @dfn{tail--concatenated pair} or @dfn{tconc}; it structure is the
following, where the tconc is the first pair:

@example
 -------       -------       -------       -------
| A | D | --> | A | D | --> | A | D | --> | A | D |--> NULL
 -------       -------       -------       -------
  |                                         ^
  |                                         |
   -----------------------------------------
@end example

@noindent
the first word in the first pair holds a pointer to the last pair in the chain; when the list is
empty, the structure is:

@example
 -------
| A | D | --> NULL
 -------
  |
   --> NULL
@end example

It is sometimes useful to create an @dfn{association list} or @dfn{alist} as a simple key/value
structure; an alist has the following structure:

@example
 -------       -------       -------       -------
| A | D | --> | A | D | --> | A | D | --> | A | D | --> NULL
 -------       -------       -------       -------
  |             |             |             |
  v             v             v             v
 -------       -------       -------       -------
| A | D |     | A | D |     | A | D |     | A | D |
 -------       -------       -------       -------
  |   |         |   |         |   |         |   |
 key val       key val       key val       key val
@end example

@noindent
we find a value by performing a linear search for the corresponding key.  An empty alist is the
pointer @cnull{}.

@c page
@node init
@chapter Library initialisation


@deftypefun void ccpair_library_init (void)
Initialise the internal structures of the library.  It is fine to call this function multiple times.

@quotation
@strong{NOTE} This function is defined with the @gcc{} attribute @code{constructor}, so, when the
library is built with @gcc{}: it will be called automatically by the library initialisation code.
@end quotation
@end deftypefun

@c page
@node version
@chapter Version functions


The installed libraries follow version numbering as established by the @gnu{} Autotools.  For an
explanation of interface numbers as managed by @gnu{} Libtool @xref{Libtool versioning, interface,
Libtool's versioning system, libtool, Shared library support for @gnu{}}.


@deftypefun {const char *} ccpair_version_string (void)
Return a pointer to a statically allocated @asciiz{} string representing the interface version
number.
@end deftypefun


@deftypefun int ccpair_version_interface_current (void)
Return an integer representing the library interface current number.
@end deftypefun


@deftypefun int ccpair_version_interface_revision (void)
Return an integer representing the library interface current revision number.
@end deftypefun


@deftypefun int ccpair_version_interface_age (void)
Return an integer representing the library interface current age.
@end deftypefun

@c page
@node typedefs
@chapter Some type definitions


@deftp {Integer Type} ccpair_idx_t
Type of indexes used to reference pairs and items in lists.  It is an alias for @objtype{size_t}.
@end deftp


@deftp {Integer Type} ccpair_len_t
Type of integers used to represent list lengths.  It is an alias for @objtype{size_t}.
@end deftp

@c page
@node pairs
@chapter Pair data structures


Pairs are meant to compose simply linked lists as follows:

@example
 -------
| A | D |
 -------
  |   |     -------
  v    --> | A | D |
value       -------
             |   |     -------
             v    --> | A | D |
           value       -------
                        |   |
                        v    --> NULL
                      value
@end example

@noindent
where both @var{A} and @var{D} are pointers; this picture represents the layout of a list of three
items.  Pairs are meant to be allocated on the heap, using a custom memory allocator.


@deftp {Struct Typedef} ccpair_stru_t
Structure type representing a pair.  It is composed of two machine words.  From the point of view of
client code: @strong{pairs are immutable}.
@end deftp


@deftp {Pointer Typedef} ccpair_t
Pointer type representing a pointer to @objtype{ccpair_stru_t}.
@end deftp


@deftypefun uintptr_t ccpair_car (ccpair_t @var{P})
Return the first value in the pair as unsigned integer.  The first value in a pair is called an
@dfn{item}.
@end deftypefun


@deftypefun ccpair_t ccpair_cdr (ccpair_t @var{P})
Return the second value in the pair as pointer to pair.
@end deftypefun


@deftypefun ccpair_t ccpair_car_pair (ccpair_t @var{P})
Return the first value in the pair as pointer to pair.  This function is useful when the pair is a
node in a tree.
@end deftypefun


@deftypefun uintptr_t ccpair_cdr_value (ccpair_t @var{P})
Return the second value in the pair as unsigned integer.
@end deftypefun

@c page
@node memory
@chapter Memory allocation


@value{PACKAGE} uses the memory allocators @api{} defined by CCMemory.  There is a peculiarity:
@value{PACKAGE} can correctly use only allocators whose memory releasing function does not raise
exceptions, or raises ignorable exceptions.

By default, @value{PACKAGE} uses the standard allocator @code{ccmem_standard_allocator};
@ccmemoryref{std, The standard allocator}.


@deftypefun {ccmem_allocator_t const *} ccpair_register_allocator (ccmem_allocator_t const * @var{allocator})
Register a new custom allocator and return a pointer to the previous one.
@end deftypefun


All the following functions use the currently selected pair allocator.


@deftypefun ccpair_t ccpair_alloc (cce_location_t * @var{L})
Allocate a new pair structure and return a pointer to it.  If successful: return a pointer to the
new structure (this function never returns @cnull{}); otherwise raise an exception performing a
non--local exit to @var{L}.
@end deftypefun


@deftypefun void ccpair_free (ccpair_t @var{P})
Release the memory previously allocated for a pair with @cfunc{ccpair_alloc}.  If @var{P} is
@cnull{}: nothing happens.
@end deftypefun


@deftypefun void ccpair_free_list (ccpair_t @var{P})
Release the memory previously allocated for a list of pairs with @cfunc{ccpair_alloc}.  If @var{P}
is @cnull{}: nothing happens.

@quotation
@strong{NOTE} This function is @strong{unable} to correctly free circular lists.
@end quotation
@end deftypefun

@c page
@node constructors
@chapter Constructing pairs and lists


@menu
* constructors pairs::          Pair constructors.
* constructors lists::          List constructors.
@end menu

@c page
@node constructors pairs
@section Pair constructors


@deftypefun ccpair_t ccpair_cons (cce_location_t * @var{L}, uintptr_t @var{A}, ccpair_t @var{D})
Allocate a new pair using the currently selected memory allocator; initialise the first value with
@var{A} and the second value with @var{D}.  If successful: return a pointer to the new structure
(this function never returns @cnull{}); otherwise raise an exception performing a non--local exit to
@var{L}.

@example
cce_location_t  L[1]
ccpair_t        P;

if (cce_location(L)) @{
  cce_run_error_handlers_final(L);
@} else @{
  P = ccpair_cons(L, 1, NULL);
  ...
  cce_run_cleanup_handlers(L);
@}
@end example
@end deftypefun


@deftypefun ccpair_t ccpair_cons_improper (cce_location_t * @var{L}, uintptr_t @var{A}, uintptr_t @var{D})
Like @cfunc{ccpair_cons} but accept a @code{uintptr_t} as second argument.

@example
cce_location_t  L[1]
ccpair_t        P;

if (cce_location(L)) @{
  cce_run_error_handlers_final(L);
@} else @{
  P = ccpair_cons_improper(L, 1, 2);
  ...
  cce_run_cleanup_handlers(L);
@}
@end example
@end deftypefun


@deftypefun ccpair_t ccpair_cons_node (cce_location_t * @var{L}, ccpair_t @var{A}, ccpair_t @var{D})
Like @cfunc{ccpair_cons} but accept a @code{ccpair_t} as first argument.

@example
cce_location_t  L[1]
ccpair_t        P, Q;
cce_handler_t   P_H[1], Q_H[1];

if (cce_location(L)) @{
  cce_run_error_handlers_final(L);
@} else @{
  Q = ccpair_cons_node(L, 1, NULL);
  cce_error_handler_pair_init(L, Q_H, Q);

  P = ccpair_cons_node(L, Q, NULL);

  ...
  cce_run_cleanup_handlers(L);
@}
@end example
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Constructors with exception handlers initialisation


@deftypefun ccpair_t ccpair_cons_error_handler (cce_destination_t @var{L}, uintptr_t @var{A}, ccpair_t @var{D}, cce_handler_t * @var{H})
@deftypefunx ccpair_t ccpair_cons_cleanup_handler (cce_destination_t @var{L}, uintptr_t @var{A}, ccpair_t @var{D}, cce_handler_t * @var{H})
Like @cfunc{ccpair_cons}, but initialise an error or cleanup handler to release the memory of the
pair; the memory will be released with @cfunc{ccpair_free}.  We can use these functions as follows:

@example
cce_location_t  L[1];
cce_handler_t   H[1];

if (cce_location(L)) @{
  cce_run_error_handlers_final(L);
@} else @{
  ccpair_t  P = ccpair_cons_cleanup_handler(L, 1, NULL, H);

  /* Do something with P here. */
  cce_run_cleanup_handlers(L);
@}
@end example
@end deftypefun


@deftypefun ccpair_t ccpair_cons_improper_error_handler (cce_destination_t @var{L}, uintptr_t @var{A}, uintptr_t @var{D}, cce_handler_t * @var{H})
@deftypefunx ccpair_t ccpair_cons_improper_cleanup_handler (cce_destination_t @var{L}, uintptr_t @var{A}, uintptr_t @var{D}, cce_handler_t * @var{H})
Like @cfunc{ccpair_cons_improper}, but initialise an error or cleanup handler to release the memory
of the pair; the memory will be released with @cfunc{ccpair_free}.

@example
cce_location_t  L[1]
ccpair_t        P;
cce_handler_t   P_H[1];

if (cce_location(L)) @{
  cce_run_error_handlers_final(L);
@} else @{
  P = ccpair_cons_improper_cleanup_handler(L, 1, 2, P_H);
  ...
  cce_run_cleanup_handlers(L);
@}
@end example
@end deftypefun


@deftypefun ccpair_t ccpair_cons_node_error_handler (cce_destination_t @var{L}, ccpair_t @var{A}, ccpair_t @var{D}, cce_handler_t * @var{H})
@deftypefunx ccpair_t ccpair_cons_node_cleanup_handler (cce_destination_t @var{L}, ccpair_t @var{A}, ccpair_t @var{D}, cce_handler_t * @var{H})
Like @cfunc{ccpair_cons_node}, but initialise an error or cleanup handler to release the memory of
the pair; the memory will be released with @cfunc{ccpair_free}.

@example
cce_location_t  L[1]
cce_handler_t   P_H[1], Q_H[1];

if (cce_location(L)) @{
  cce_run_error_handlers_final(L);
@} else @{
  ccpair_t      P, Q;

  Q = ccpair_cons_error_handler(L, 1, NULL, Q_H);
  P = ccpair_cons_node_cleanup_handler(L, Q, NULL, P_H);

  ...
  cce_run_cleanup_handlers(L);
@}
@end example
@end deftypefun

@c page
@node constructors lists
@section List constructors


@deftypefun ccpair_t ccpair_list (cce_destination_t @var{L}, ccpair_item_constructor_t * @var{C}, ccpair_item_destructor_t * @var{D})
Build a new list filling it with items and return a pointer to the first pair.  If an error occurs:
raise an exception by performing a non--local exit to @var{L}.

New items are built with the constructor @var{C}, which receives as argument the index of the item
in the list, starting with zero.  When all the items meant to be in the list have been built: the
constructor must raise a break exception with using the CCExceptions @api{} as follows:

@example
cce_raise(L, cce_condition_new_break());
@end example

If an error occurs while building the list: the pairs already allocated are released; the items
already built are released using the destructor @var{D}.
@end deftypefun


@deftypefun ccpair_t ccpair_list_cleanup_handler (cce_destination_t @var{L}, ccpair_item_constructor_t * @var{C}, ccpair_item_destructor_t * @var{D}, ccpair_list_item_handler_t * @var{H})
@deftypefunx ccpair_t ccpair_list_error_handler (cce_destination_t @var{L}, ccpair_item_constructor_t * @var{C}, ccpair_item_destructor_t * @var{D}, ccpair_list_item_handler_t * @var{H})
Like @cfunc{ccpair_list}, but, when successful, register the resulting list into the cleanup or
error handler @var{H}.
@end deftypefun


To build an example of list construction, let's consider the following data values used as simple
item payload:

@example
typedef struct data_t @{
  ccpair_idx_t  N;
@} data_t;

data_t *
data_constructor (cce_destination_t L, ccpair_idx_t N)
@{
  data_t * item = cce_sys_malloc(sizeof(data_t));
  item->N = N;
  return item;
@}

void
data_destructor (data_t * data)
@{
  free(item);
@}
@end example

@noindent
we can put @math{3} such data values into a list built with @cfunc{ccpair_list} using the following
constructor and destructor:

@example
uintptr_t
item_constructor (cce_destination_t L, ccpair_idx_t idx)
@{
  switch (idx) @{
  case 0:
  case 1:
  case 2:
    return data_constructor(L, idx);
  case 3:
    cce_raise(L, cce_condition_new_break());
  default:
    cce_raise(L, cce_condition_new_logic_error());
  @}
@}

void
item_destructor (uintptr_t item)
@{
  data_t * data = (data_t *)item;
  data_destructor(data);
@}
@end example

@noindent
we can build the list using @cfunc{ccpair_list} with the following code:

@example
cce_location_t                L[1];
ccpair_t                      P;
ccpair_list_item_handler_t    P_H[1];

if (cce_location(L)) @{
  cce_run_error_handlers_final(L);
@} else @{
  P = ccpair_list(L, item_constructor, item_destructor);
  ccpair_cleanup_handler_list_item_init(L, P_H, P,
     item_destructor);
  ...
  cce_run_cleanup_handlers(L);
@}
@end example

@noindent
we can build the list using @cfunc{ccpair_list_cleanup_handler} with the following code:

@example
cce_location_t                L[1];
ccpair_t                      P;
ccpair_list_item_handler_t    P_H[1];

if (cce_location(L)) @{
  cce_run_error_handlers_final(L);
@} else @{
  P = ccpair_list_cleanup_handler(L, item_constructor,
     item_destructor, P_H);
  ...
  cce_run_cleanup_handlers(L);
@}
@end example

@c page
@node inspection
@chapter Inspecting lists


@deftypefun ccpair_len_t ccpair_length (cce_location_t @var{L}, ccpair_t @var{P})
Return the number of pairs in the list beginning with @var{P}.  If @var{P} is @cnull{}: return zero.
If the operand is a circular list: raise an exception by performing a non--local exit to @var{L}.
@end deftypefun


@deftypefun bool ccpair_is_empty (ccpair_t @var{P})
@deftypefunx bool ccpair_is_null (ccpair_t @var{P})
Return @ctrue{} if @var{P} represents the empty list, that is: if @var{P} is @cnull{}.  Otherwise
return @cfalse{}.
@end deftypefun


@deftypefun bool ccpair_is_last (ccpair_t @var{P})
Return @ctrue{} if @var{P} is the last pair in its list, that is: if @var{P} is not @cnull{} and the
second item in @var{P} is @cnull{}.  Otherwise return @cfalse{}.
@end deftypefun


@deftypefun bool ccpair_is_circular (ccpair_t @var{P})
Return @ctrue{} if the list referenced by @var{P} is circular; otherwise return @cfalse{}.
@end deftypefun

@c page
@node accessors
@chapter Accessing items in lists


@menu
* accessors pairs::             Accessing list pairs.
* accessors items::             Accessing list items.
@end menu

@c page
@node accessors pairs
@section Accessing list pairs


@deftypefun ccpair_t ccpair_ref_pair (cce_location_t @var{L}, ccpair_t @var{P}, ccpair_idx_t @var{idx})
Return a pointer to the pair at the zero--based index @var{idx} in the list whose first pair is
@var{P}.  If the list length is less than or equal to @var{idx}: raise an exception by performing a
non--local exit to @var{L}.
@end deftypefun


@deftypefun ccpair_t ccpair_last_pair (cce_location_t * @var{L}, ccpair_t @var{P})
Return a pointer to the last pair in the list @var{P}.  If @var{P} is @cnull{}: raise an exception
by performing a non--local exit to @var{L}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Numbered accessors


@deftypefun ccpair_t ccpair_first_pair (cce_location_t @var{L}, ccpair_t @var{P})
Return the first pair in the list whose first pair is @var{P} (that is: return @var{P} itself).  If
the list is empty (that is: @var{P} is @cnull{}): raise an exception by performing a non--local exit
to @var{L}.
@end deftypefun


@deftypefun ccpair_t ccpair_second_pair (cce_location_t @var{L}, ccpair_t @var{P})
Return the second pair in the list whose first pair is @var{P}.  If the list has less than two
pairs: raise an exception by performing a non--local exit to @var{L}.
@end deftypefun


@deftypefun ccpair_t ccpair_third_pair (cce_location_t @var{L}, ccpair_t @var{P})
Return the third pair in the list whose first pair is @var{P}.  If the list has less than three
pairs: raise an exception by performing a non--local exit to @var{L}.
@end deftypefun


@deftypefun ccpair_t ccpair_fourth_pair (cce_location_t @var{L}, ccpair_t @var{P})
Return the fourth pair in the list whose first pair is @var{P}.  If the list has less than four
pairs: raise an exception by performing a non--local exit to @var{L}.
@end deftypefun


@deftypefun ccpair_t ccpair_fifth_pair (cce_location_t @var{L}, ccpair_t @var{P})
Return the fifth pair in the list whose first pair is @var{P}.  If the list has less than five
pairs: raise an exception by performing a non--local exit to @var{L}.
@end deftypefun


@deftypefun ccpair_t ccpair_sixth_pair (cce_location_t @var{L}, ccpair_t @var{P})
Return the sixth pair in the list whose first pair is @var{P}.  If the list has less than six pairs:
raise an exception by performing a non--local exit to @var{L}.
@end deftypefun


@deftypefun ccpair_t ccpair_seventh_pair (cce_location_t @var{L}, ccpair_t @var{P})
Return the seventh pair in the list whose first pair is @var{P}.  If the list has less than seven
pairs: raise an exception by performing a non--local exit to @var{L}.
@end deftypefun


@deftypefun ccpair_t ccpair_eighth_pair (cce_location_t @var{L}, ccpair_t @var{P})
Return the eighth pair in the list whose first pair is @var{P}.  If the list has less than eigth
pairs: raise an exception by performing a non--local exit to @var{L}.
@end deftypefun


@deftypefun ccpair_t ccpair_nineth_pair (cce_location_t @var{L}, ccpair_t @var{P})
Return the nineth pair in the list whose first pair is @var{P}.  If the list has less than nine
pairs: raise an exception by performing a non--local exit to @var{L}.
@end deftypefun


@deftypefun ccpair_t ccpair_tenth_pair (cce_location_t @var{L}, ccpair_t @var{P})
Return the tenth pair in the list whose first pair is @var{P}.  If the list has less than ten pairs:
raise an exception by performing a non--local exit to @var{L}.
@end deftypefun

@c page
@node accessors items
@section Accessing list items


@deftypefun uintptr_t ccpair_ref (cce_location_t @var{L}, ccpair_t @var{P}, ccpair_idx_t @var{idx})
Return the item at the zero--based index @var{idx} in the list whose first pair is @var{P}.  If the
list length is less than or equal to @var{idx}: raise an exception by performing a non--local exit
to @var{L}.
@end deftypefun


@deftypefun uintptr_t ccpair_pair (cce_location_t * @var{L}, ccpair_t @var{P})
Return the item of the last pair in the list @var{P}.  If @var{P} is @cnull{}: raise an exception by
performing a non--local exit to @var{L}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Numbered accessors


@deftypefun uintptr_t ccpair_first (cce_location_t @var{L}, ccpair_t @var{P})
Return the first item in the list whose first pair is @var{P}.  If the list is empty (that is:
@var{P} is @cnull{}): raise an exception by performing a non--local exit to @var{L}.
@end deftypefun


@deftypefun uintptr_t ccpair_second (cce_location_t @var{L}, ccpair_t @var{P})
Return the second item in the list whose first pair is @var{P}.  If the list has less than two
pairs: raise an exception by performing a non--local exit to @var{L}.
@end deftypefun


@deftypefun uintptr_t ccpair_third (cce_location_t @var{L}, ccpair_t @var{P})
Return the third item in the list whose first pair is @var{P}.  If the list has less than three
pairs: raise an exception by performing a non--local exit to @var{L}.
@end deftypefun


@deftypefun uintptr_t ccpair_fourth (cce_location_t @var{L}, ccpair_t @var{P})
Return the fourth item in the list whose first pair is @var{P}.  If the list has less than four
pairs: raise an exception by performing a non--local exit to @var{L}.
@end deftypefun


@deftypefun uintptr_t ccpair_fifth (cce_location_t @var{L}, ccpair_t @var{P})
Return the fifth item in the list whose first pair is @var{P}.  If the list has less than five
pairs: raise an exception by performing a non--local exit to @var{L}.
@end deftypefun


@deftypefun uintptr_t ccpair_sixth (cce_location_t @var{L}, ccpair_t @var{P})
Return the sixth item in the list whose first pair is @var{P}.  If the list has less than six pairs:
raise an exception by performing a non--local exit to @var{L}.
@end deftypefun


@deftypefun uintptr_t ccpair_seventh (cce_location_t @var{L}, ccpair_t @var{P})
Return the seventh item in the list whose first pair is @var{P}.  If the list has less than seven
pairs: raise an exception by performing a non--local exit to @var{L}.
@end deftypefun


@deftypefun uintptr_t ccpair_eighth (cce_location_t @var{L}, ccpair_t @var{P})
Return the eighth item in the list whose first pair is @var{P}.  If the list has less than eigth
pairs: raise an exception by performing a non--local exit to @var{L}.
@end deftypefun


@deftypefun uintptr_t ccpair_nineth (cce_location_t @var{L}, ccpair_t @var{P})
Return the nineth item in the list whose first pair is @var{P}.  If the list has less than nine
pairs: raise an exception by performing a non--local exit to @var{L}.
@end deftypefun


@deftypefun uintptr_t ccpair_tenth (cce_location_t @var{L}, ccpair_t @var{P})
Return the tenth item in the list whose first pair is @var{P}.  If the list has less than ten pairs:
raise an exception by performing a non--local exit to @var{L}.
@end deftypefun

@c page
@node conditions
@chapter Exceptional condition objects


@value{PACKAGE} uses the external library CCExceptions to signal exceptional conditions and errors
through non--local exits; @xref{Top, CCExceptions, CCExceptions, ccexceptions, CCExceptions}.

The functions will raise exceptional conditions with @cfunc{cce_raise} and expect the caller to
intercept them using the @code{cce_location_t} mechanics.  The basic code template is:

@example
#include <ccpair.h>

cce_location_t  L[1];

if (cce_location(L)) @{
  /* Handle errors here. */
  cce_run_error_handlers_final(L);
@} else @{
  /* Do something useful here. */
  cce_run_cleanup_handlers(L);
@}
@end example

@menu
* conditions not-enough::       Not enough items in list.
* conditions empty::            Invalid empty list as operand.
* conditions circular::         Invalid circular list as operand.
@end menu

@c page
@node conditions not-enough
@section Not enough items in list


@cindex Not enough items in list, exceptional condition
@cindex Exceptional conditions, not enough items in list


@deftp {Struct Typedef} ccpair_descriptor_not_enough_items_t
Type of data structure representing the exceptional--condition descriptor for the error: not enough
items in list.  It has the following public fields:

@table @code
@item cce_descriptor_t descriptor
The condition descriptor's base values.
@end table

The parent of this type descriptor is the one referenced by @code{cce_descriptor_logic_error_ptr};
@xref{conditions logic error, CCExceptions, CCExceptions, ccexceptions, CCExceptions}.
@end deftp


@deftp {Struct Typedef} ccpair_condition_not_enough_items_t
Type of data structure representing the exceptional--condition object for the error: not enough
items in list.  It has the following public fields:

@table @code
@item cce_condition_t base
The condition object's base values.
@end table
@end deftp


@deftypevr {Dynamic Constant} {const ccpair_descriptor_not_enough_items_t * const} ccpair_descriptor_not_enough_items
Pointer to a statically allocated exceptional condition descriptor.
@end deftypevr


@deftypefun {cce_condition_t const *} ccpair_condition_new_not_enough_items (void)
Return a pointer to exceptional condition object.
@end deftypefun


@deftypefun bool ccpair_condition_is_not_enough_items (cce_condition_t const * @var{C})
Return @ctrue{} if @var{C} if of type @code{ccpair_descriptor_not_enough_items}; otherwise return
@cfalse{}.
@end deftypefun


To catch this exceptional condition we can do:

@example
cce_location_t        L[1];

if (cce_location(L)) @{
  if (ccpair_condition_is_not_enough_items(cce_condition(L))) @{
    ccpair_condition_not_enough_items_t * C = \
      (ccpair_condition_not_enough_items_t *) cce_condition(L);
    do_something_with(C);
  @}
  cce_run_error_handlers_final(L);
@} else @{
  do_something(L);
  cce_run_cleanup_handlers(L);
@}
@end example

@c page
@node conditions empty
@section Invalid empty list as operand


@cindex Invalid empty list as operand, exceptional condition
@cindex Exceptional conditions, Invalid empty list as operand


@deftp {Struct Typedef} ccpair_descriptor_empty_list_t
Type of data structure representing the exceptional--condition descriptor for the error: invalid
empty list as operand.  It has the following public fields:

@table @code
@item cce_descriptor_t descriptor
The condition descriptor's base values.
@end table

The parent of this type descriptor is the one referenced by
@code{ccpair_descriptor_not_enough_items}.
@end deftp


@deftp {Struct Typedef} ccpair_condition_empty_list_t
Type of data structure representing the exceptional--condition object for the error: invalid empty
list as operand.  It has the following public fields:

@table @code
@item cce_condition_t base
The condition object's base values.
@end table
@end deftp


@deftypevr {Dynamic Constant} {const ccpair_descriptor_empty_list_t * const} ccpair_descriptor_empty_list
Pointer to a statically allocated exceptional condition descriptor.
@end deftypevr


@deftypefun {cce_condition_t const *} ccpair_condition_new_empty_list (void)
Return a pointer to exceptional condition object.
@end deftypefun


@deftypefun bool ccpair_condition_is_empty_list (cce_condition_t const * @var{C})
Return @ctrue{} if @var{C} if of type @code{ccpair_descriptor_empty_list}; otherwise return
@cfalse{}.
@end deftypefun


To catch this exceptional condition we can do:

@example
cce_location_t        L[1];

if (cce_location(L)) @{
  if (ccpair_condition_is_empty_list(cce_condition(L))) @{
    ccpair_condition_empty_list_t * C = \
      (ccpair_condition_empty_list_t *) cce_condition(L);
    do_something_with(C);
  @}
  cce_run_error_handlers_final(L);
@} else @{
  do_something(L);
  cce_run_cleanup_handlers(L);
@}
@end example

@c page
@node conditions circular
@section Invalid circular list as operand


@cindex Invalid circular list as operand, exceptional condition
@cindex Exceptional conditions, Invalid circular list as operand


@deftp {Struct Typedef} ccpair_descriptor_circular_list_t
Type of data structure representing the exceptional--condition descriptor for the error: invalid
circular list as operand.  It has the following public fields:

@table @code
@item cce_descriptor_t descriptor
The condition descriptor's base values.
@end table

The parent of this type descriptor is the one referenced by @code{cce_descriptor_logic_error_ptr};
@xref{conditions logic error, CCExceptions, CCExceptions, ccexceptions, CCExceptions}.
@end deftp


@deftp {Struct Typedef} ccpair_condition_circular_list_t
Type of data structure representing the exceptional--condition object for the error: invalid
circular list as operand.  It has the following public fields:

@table @code
@item cce_condition_t base
The condition object's base values.
@end table
@end deftp


@deftypevr {Dynamic Constant} {const ccpair_descriptor_circular_list_t * const} ccpair_descriptor_circular_list
Pointer to a statically allocated exceptional condition descriptor.
@end deftypevr


@deftypefun {cce_condition_t const *} ccpair_condition_new_circular_list (void)
Return a pointer to exceptional condition object.
@end deftypefun


@deftypefun bool ccpair_condition_is_circular_list (cce_condition_t const * @var{C})
Return @ctrue{} if @var{C} if of type @code{ccpair_descriptor_circular_list}; otherwise return
@cfalse{}.
@end deftypefun


To catch this exceptional condition we can do:

@example
cce_location_t        L[1];

if (cce_location(L)) @{
  if (ccpair_condition_is_circular_list(cce_condition(L))) @{
    ccpair_condition_circular_list_t * C = \
      (ccpair_condition_circular_list_t *) cce_condition(L);
    do_something_with(C);
  @}
  cce_run_error_handlers_final(L);
@} else @{
  do_something(L);
  cce_run_cleanup_handlers(L);
@}
@end example

@c page
@node handlers
@chapter Exceptional condition handlers


@menu
* handlers pairs::              Handler for pair release.
* handlers lists::              Handler for list release.
* handlers items::              Handler for item release.
* handlers itpairs::            Handler for pair-and-item release.
* handlers itlists::            Handler for list-and-items release.
@end menu

@c page
@node handlers pairs
@section Handler for pair release


We can handle pairs that must be released with the function @cfunc{ccpair_free} as follows:

@example
cce_location_t  L[1];
cce_handler_t   H[1];

if (ccpair_location(L)) @{
  cce_run_error_handlers_final(L);
@} else @{
  ccpair_t P = ccpair_cons(1, NULL);
  ccpair_cleanup_handler_pair_init(L, H, P);
  /* Do something with P here. */
  cce_run_cleanup_handlers(L);
@}
@end example

The following symbols are defined in the header file @file{ccpair.h}.


@deftypefun void ccpair_cleanup_handler_pair_init (cce_location_t * @var{L}, cce_handler_t * @var{H}, ccpair_t @var{P})
@deftypefunx void ccpair_error_handler_pair_init (cce_location_t * @var{L}, cce_handler_t * @var{H}, ccpair_t @var{P})
Register @var{H} as cleanup or error handler in the context of @var{L}.  The handler function will
release the memory allocated for the pair referenced by @var{P} using the function
@cfunc{ccpair_free}.
@end deftypefun

@c page
@node handlers lists
@section Handler for list release


We can handle lists that must be released with the function @cfunc{ccpair_free_list} as follows:

@example
cce_location_t  L[1];
cce_handler_t   H[1];

if (ccpair_location(L)) @{
  cce_run_error_handlers_final(L);
@} else @{
  ccpair_t P = ccpair_cons(1, ccpair_cons(2, NULL));
  ccpair_cleanup_handler_list_init(L, H, P);
  /* Do something with P here. */
  cce_run_cleanup_handlers(L);
@}
@end example

The following symbols are defined in the header file @file{ccpair.h}.


@deftypefun void ccpair_cleanup_handler_list_init (cce_location_t * @var{L}, cce_handler_t * @var{H}, ccpair_t @var{P})
@deftypefunx void ccpair_error_handler_list_init (cce_location_t * @var{L}, cce_handler_t * @var{H}, ccpair_t @var{P})
Register @var{H} as cleanup or error handler in the context of @var{L}.  The handler function will
release the memory allocated for the list referenced by @var{P} using the function
@cfunc{ccpair_free_list}.
@end deftypefun

@c page
@node handlers items
@section Handler for item release


It happens that we want to build an item object and then store it into a pair; if an error occurs we
want to release such item; the handlers defined by @value{PACKAGE} allow us to do so using the
exceptions mechanism.  We can define our item handler types using the CCExceptions @api{}; the
handler defined by @value{PACKAGE} is used internally when building a list.

Obviously, there is no predefined destructor for items, so we have to explicitly select one.

Here is an example of item and pair construction:

@example
uintptr_t
item_constructor (cce_destination_t L)
@{
  /* Build and return an item. */
@}

void
item_destructor (uintptr_t item)
@{
  /* Release an item. */
@}

void
main (void)
@{
  cce_location_t        L[1];
  cce_handler_t         pair_H[1];
  ccpair_item_handler_t item_H[1];

  if (ccpair_location(L)) @{
    cce_run_error_handlers_final(L);
    exit(EXIT_FAILURE);
  @} else @{
    uintptr_t   item;
    ccpair_t    P;

    item = item_constructor(L);
    ccpair_cleanup_handler_item_init(L, item_H, item,
       item_destructor);

    P = ccpair_cons(item, NULL);
    ccpair_cleanup_handler_pair_init(L, pair_H, P);

    /* Do something with P here. */
    cce_run_cleanup_handlers(L);
  @}
@}
@end example

The following symbols are defined in the header file @file{ccpair.h}.


@deftp {Struct Typedef} ccpair_item_handler_t
Type of data structures used has exception handlers for items.
@end deftp


@deftypefun void ccpair_cleanup_handler_item_init (cce_location_t * @var{L}, ccpair_item_handler_t * @var{H}, uintptr_t @var{item}, ccpair_item_destructor_t * @var{D})
@deftypefunx void ccpair_error_handler_item_init (cce_location_t * @var{L}, ccpair_item_handler_t * @var{H}, uintptr_t @var{item}, ccpair_item_destructor_t * @var{D})
Register @var{H} as cleanup or error handler in the context of @var{L}.  The handler function will
release the resources associated to @var{item} using the supplied destructor function @var{D}.
@end deftypefun

@c page
@node handlers itpairs
@section Handler for pair--and--item release


It happens that we want to build an item object and then store it into a pair; if an error occurs we
want to release such item; after the item has been put into a pair we may want to release the pair
and the item together using a specialised item destructor; the handlers defined by @value{PACKAGE}
allow us to do so using the exceptions mechanism.

Obviously, there is no predefined destructor for items, so we have to explicitly select one.

We must be careful in separating the two moments: item and pair construction; pair--and--item
destruction.

Here is an example of item and pair construction:

@example
uintptr_t
item_constructor (cce_destination_t L)
@{
  /* Build and return an item. */
@}

void
item_destructor (uintptr_t item)
@{
  /* Release an item. */
@}

void
main (void)
@{
  ccpair_t              P;

  /* Build the item and the pair.  Upon exiting this block: we
     release the item only if an error has occurred. */
  @{
    cce_location_t              L[1];
    cce_handler_t               pair_H[1];
    ccpair_item_handler_t       item_H[1];

    if (ccpair_location(L)) @{
      cce_run_error_handlers_final(L);
      exit(EXIT_FAILURE);
    @} else @{
      uintptr_t   item;

      item = item_constructor(L);
      ccpair_error_handler_item_init(L, item_H, item,
         item_destructor);

      P = ccpair_cons(item, NULL);

      cce_run_cleanup_handlers(L);
    @}
  @}

  /* Now use the pair and finally release both the pair
     and the item. */
  @{
    cce_location_t              L[1];
    ccpair_pair_item_handler_t  pair_H[1];

    if (ccpair_location(L)) @{
      cce_run_error_handlers_final(L);
      exit(EXIT_FAILURE);
    @} else @{
      ccpair_cleanup_handler_pair_item_init(L, pair_H, P);
      /* Do something with P here. */
      cce_run_cleanup_handlers(L);
    @}
  @}
@}
@end example

The following symbols are defined in the header file @file{ccpair.h}.


@deftp {Struct Typedef} ccpair_pair_item_handler_t
Type of data structures used has exception handlers for pairs with items.
@end deftp


@deftypefun void ccpair_cleanup_handler_pair_item_init (cce_location_t * @var{L}, ccpair_pair_item_handler_t * @var{H}, ccpair_t @var{P}, ccpair_item_destructor_t * @var{D})
@deftypefunx void ccpair_error_handler_pair_item_init (cce_location_t * @var{L}, ccpair_pair_item_handler_t * @var{H}, ccpair_t @var{P}, ccpair_item_destructor_t * @var{D})
Register @var{H} as cleanup or error handler in the context of @var{L}.  The handler function will
release the pair @var{P} using @cfunc{ccpair_free}; it will also release the resources associated to
the item, in the pair's first word, using the supplied destructor function @var{D}.
@end deftypefun

@c page
@node handlers itlists
@section Handler for list--and--items release


It happens that we want to build item objects and then store them into a list; if an error occurs we
want to release such items; after the items have been put into a list we may want to release the
list and the items together using a specialised item destructor; the handlers defined by
@value{PACKAGE} allow us to do so using the exceptions mechanism.

Obviously, there is no predefined destructor for items, so we have to explicitly select one.  A
single destructor can be selected for all the items.

We must be careful in separating the two moments: item and list construction; list--and--items
destruction.

Here is an example of items and list construction:

@example
uintptr_t
item_constructor (cce_destination_t L)
@{
  /* Build and return an item. */
@}

void
item_destructor (uintptr_t item)
@{
  /* Release an item. */
@}

ccpair_t
make_list_with_items (cce_destination_t upper_L)
/* Build the items and the list.  Upon exiting this block: we
   release the items and the second pair only if an error has
   occurred. */
@{
  cce_location_t        L[1];
  cce_handler_t         P_H[1], Q_H[1];
  ccpair_item_handler_t item_P_H[1], item_Q_H[1];
  ccpair_t              head;

  if (ccpair_location(L)) @{
    cce_run_error_handlers_raise(L, upper_L);
  @} else @{
    ccpair_t          P, Q;
    uintptr_t         item_P, item_Q;

    item_P = item_constructor(L);
    ccpair_error_handler_item_init(L, item_P_H, item_P,
       item_destructor);

    item_Q = item_constructor(L);
    ccpair_error_handler_item_init(L, item_Q_H, item_Q,
       item_destructor);

    Q = ccpair_cons(item_Q, NULL);
    ccpair_error_handler_pair_init(L, Q_H, Q);

    P = ccpair_cons(item_P, Q);

    /* The pair P is the head of the list. */
    head = P;

    cce_run_cleanup_handlers(L);
  @}

  return head;
@}

void
main (void)
@{
  cce_location_t              L[1];
  ccpair_list_item_handler_t  head_H[1];

  /* Now use the list and finally release both the list
     and the items. */
  if (ccpair_location(L)) @{
    cce_run_error_handlers_final(L);
    exit(EXIT_FAILURE);
  @} else @{
    ccpair_t    head = make_list_with_items(L);
    ccpair_cleanup_handler_list_item_init(L, head_H, head,
       item_destructor);
    /* do something with HEAD here */
    cce_run_cleanup_handlers(L);
  @}
@}
@end example

Here is the same example written with constructors that know about handlers:

@example
uintptr_t
item_constructor (cce_destination_t L, ccpair_item_handler_t * H)
@{
  uintptr_t     item = make_item(L);
  ccpair_error_handler_item_init(L, H, item, item_destructor);
  return item;
@}

void
item_destructor (uintptr_t item)
@{
  /* Release an item. */
@}

ccpair_t
make_list_with_cleanup (cce_destination_t upper_L,
                        ccpair_list_item_handler_t * head_H)
/* Build the items and the list.  Upon exiting this block: we
   release the items and the second pair only if an error has
   occurred. */
@{
  cce_location_t              L[1];
  cce_handler_t               P_H[1], Q_H[1];
  ccpair_item_handler_t       item_P_H[1], item_Q_H[1];

  if (ccpair_location(L)) @{
    cce_run_error_handlers_raise(L, upper_L);
  @} else @{
    uintptr_t item_P = item_constructor(L, item_P_H);
    uintptr_t item_Q = item_constructor(L, item_Q_H);
    ccpair_t  Q = ccpair_cons_error_handler(item_Q, NULL, Q_H);
    ccpair_t  P = ccpair_cons(item_P, Q);

    /* The pair P is the head of the list. */
    head = P;
    cce_run_cleanup_handlers(L);
  @}

  ccpair_cleanup_handler_list_item_init(upper_L, head_H, head,
     item_destructor);
  return head;
@}

void
main (void)
@{
  cce_location_t              L[1];
  ccpair_list_item_handler_t  head_H[1];

  /* Now use the list and finally release both the list
     and the items. */
  if (ccpair_location(L)) @{
    cce_run_error_handlers_final(L);
    exit(EXIT_FAILURE);
  @} else @{
    ccpair_t    head = make_list_with_cleanup(L, head_H);
    /* do something with HEAD here */
    cce_run_cleanup_handlers(L);
  @}
@}
@end example

The following symbols are defined in the header file @file{ccpair.h}.


@deftp {Struct Typedef} ccpair_list_item_handler_t
Type of data structures used has exception handlers for lists with items.
@end deftp


@deftypefun void ccpair_cleanup_handler_list_item_init (cce_location_t * @var{L}, ccpair_list_item_handler_t * @var{H}, ccpair_t @var{P}, ccpair_item_destructor_t * @var{D})
@deftypefunx void ccpair_error_handler_list_item_init (cce_location_t * @var{L}, ccpair_list_item_handler_t * @var{H}, ccpair_t @var{P}, ccpair_item_destructor_t * @var{D})
Register @var{H} as cleanup or error handler in the context of @var{L}.  The handler function will
release every pair in the list @var{P} using @cfunc{ccpair_free}; it will also release the resources
associated to the items, in the pairs' first words, using the supplied destructor function @var{D}.
@end deftypefun

@c page
@c ------------------------------------------------------------
@c Appendices.
@c ------------------------------------------------------------

@include lgpl-3.0.texi
@include fdl-1.3.texi

@c page
@node references
@appendix Bibliography and references


The documentation of @value{PACKAGE} is available online:

@center @value{DOCUMENTATION_URL}

@noindent
the latest release of this package can be downloaded from:

@center @value{DOWNLOAD_URL}

@noindent
development takes place at:

@center @value{GITHUB_URL}

@noindent
and as backup at:

@center @value{BITBUCKET_URL}

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file

