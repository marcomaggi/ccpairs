\input texinfo.tex
@c %**start of header
@setfilename ccpairs.info
@settitle CCPairs
@c %**end of header

@include version.texi
@include macros.texi

@c page
@c ------------------------------------------------------------
@c Local macros.
@c ------------------------------------------------------------


@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      CCPairs

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    CCPairs

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           ccpairs

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{marco.maggi-ipsu@@poste.it}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2017, 2018, 2019, 2020

@c ------------------------------------------------------------

@set CCExceptionsVersion       0.10.0
@set CCMemoryVersion           0.3.0
@set CCStructsVersion          0.4.0
@c @set CCStringsVersion          0.1.0
@set CCTestsVersion            0.5.0

@c ------------------------------------------------------------

@set PackageAutoconfPrefix              CCPAIRS
@set PackagePkgconfigModule             ccpairs
@set PackageLibsVar                     @env{CCPAIRS_LIBS}
@set PackageCflagsVar                   @env{CCPAIRS_CFLAGS}
@c This is the stem of the library in "libccpairs.so".
@set PackageLibstem                     ccpairs
@set PackageApiPrefixLower              ccpairs_
@set PackageApiPrefixUpper              CCPAIRS_

@set PackageHeader                      ccpairs.h
@set PackageHeaderFile                  @file{@value{PackageHeader}}

@set GithubUrl                 @url{https://github.com/marcomaggi/@value{PACKAGE_NICKNAME}}
@set BitbucketUrl              @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}}
@set DownloadUrl               @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}/downloads}
@set DocumentationUrl          @url{https://marcomaggi.github.io/docs/@value{PACKAGE_NICKNAME}.html}

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
This document describes version @value{VERSION} of @value{PACKAGE}, a C11 language library
implementing a simply linked lists data structures, in the style of the Scheme language.

The library supports @posix{} platforms.  The library depends on the packages: CCExceptions, at
least version @value{CCExceptionsVersion}; CCMemory, at least version @value{CCMemoryVersion};
CCStructs, at least version @value{CCStructsVersion}.  To run the test suite: the package depends
upon the package CCTests, at least version @value{CCTestsVersion}.

The package is distributed under the terms of the @gnu{} Lesser General Public License (@lgpl{}).

The latest release can be downloaded from:

@center @value{DownloadUrl}

@noindent
development takes place at:

@center @value{GithubUrl}

@noindent
and as backup at:

@center @value{BitbucketUrl}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}

@quotation
Permission is granted to copy, distribute and/or modify this document under the terms of the @gnu{}
Free Documentation License, Version 1.3 or any later version published by the Free Software
Foundation; with Invariant Sections being ``@gnu{} Free Documentation License'' and ``@gnu{} Lesser
General Public License'', no Front--Cover Texts, and no Back--Cover Texts.  A copy of the license is
included in the section entitled ``@gnu{} Free Documentation License''.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @value{VERSION}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* ccpairs: (ccpairs).           Scheme pairs and lists for C11.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* init::                        Library initialisation.
* version::                     Version functions.
* typedefs::                    Some type definitions.
* pairs::                       Pair data structures.
* memory::                      Memory allocation.
* ctors::                       Constructing pairs and lists.
* inspection::                  Inspecting lists.
* accessors::                   Accessing items in lists.
* conditions::                  Exceptional condition objects.
* handlers::                    Exceptional condition handlers.
* utils::                       Utility definitions.

Appendices

* Package License::             GNU Lesser General Public License.
* Documentation License::       GNU Free Documentation License.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


This document describes version @value{VERSION} of @value{PACKAGE}, a C11 language library
implementing simply linked lists data structures, in the style of the Scheme language.

This package supports @posix{} platforms.  This package depends on the packages: CCExceptions, at
least version @value{CCExceptionsVersion}; CCMemory, at least version @value{CCMemoryVersion};
CCStructs, at least version @value{CCStructsVersion}.  To run the test suite: this package depends
upon the package CCTests, at least version @value{CCTestsVersion}.

@cindex @value{PackageHeaderFile}, header file
@cindex Header file @value{PackageHeaderFile}
@value{PACKAGE} installs the single header file @value{PackageHeaderFile}.  All the function names
in the @api{} are prefixed with @code{@value{PackageApiPrefixLower}}; all the preprocessor symbol
names are prefixed with @code{@value{PackageApiPrefixUpper}}; all the type names are prefixed with
@code{@value{PackageApiPrefixLower}} or @code{ccpair_} and suffixed with @code{_t}.

@strong{Notice that, before using the library, we need to call the global initialisation function
@cfunc{ccpairs_library_init}}.

@strong{IMPORTANT} To use the library we must enable the @posix{} features when including the
standard header files; so either we include @file{ccpair.h} as first header, or we include the
following definitions before including @strong{all} the header files:

@example
#define _POSIX_C_SOURCE         200809L
@end example

@menu
* overview linking::            Linking code with the library.
* overview ccnames::            Generated function names.
* overview exceptions::         Handling exceptional conditions.
* overview allocation::         Memory allocation for pathname instances.
* overview lists::              How lists work.
@end menu

@include overview-linking.texi
@include overview-ccnames.texi
@include overview-ccexceptions.texi
@include overview-ccmemory.texi

@c page
@node overview lists
@section How lists work


@value{PACKAGE} implements simply--linked lists in the style of the Scheme language; Scheme is a
dialect of Lisp.  A well structured, or @dfn{proper}, Scheme list is a chain of ``pairs'', where
each pair is an ordered couple of machine words:

@itemize
@item
The first or left or @dfn{car} machine word is meant to contain the list--node payload--value,
either directly in the machine word or as value referenced by a pointer.

@item
The second or right or @dfn{cdr} machine word is meant to contain a pointer to the next node in the
list, or @cnull{} if there are no more nodes.
@end itemize

Here is an example of list with three pairs, which means that there are three payload items:

@example
 ---------       ---------       ---------
| A1 | D1 | --> | A2 | D2 | --> | A3 | D3 | --> NULL
 ---------       ---------       ---------
   |               |               |
   v               v               v
 value1          value2          value3
@end example

From the point of view of the public @value{PACKAGE} @api{}: pairs are immutable; internally the
functions may mutate the pairs while building a new list.

Immutable pairs mean that it is possible and encouraged to write functions that share the tail of a
list; here is an example of lists layout where two lists share the tail:

@example
 -------       -------       -------       -------
| A | D | --> | A | D | --> | A | D | --> | A | D | --> NULL
 -------       -------       -------       -------
                              ^
 -------       -------        |
| A | D | --> | A | D | ------
 -------       -------
@end example

@noindent
care must be taken if we need to append lists that may share the tail with other lists.

By using the first word of a pair as a pointer to list: we can represent binary trees; here is an
example:

@example
 -------       -------
| A | D | --> | A | D | --> NULL
 -------       -------
  |                 |
  |                 |     -------       -------
  |                  --> | A | D | --> | A | D | --> NULL
  |                       -------       -------
  v
 -------       -------       -------
| A | D | --> | A | D | --> | A | D | --> NULL
 -------       -------       -------
  |
  v
 -------
| A | D | --> NULL
 -------
@end example

@noindent
this works only if we use some sort of tagging in the first words to distinguish a pointer to pair
from a payload value.

Unless otherwise specified: the functions of this library @strong{do not} work with circular lists.
A circular list looks as follows:

@example
 -------       -------       -------       -------
| A | D | --> | A | D | --> | A | D | --> | A | D |
 -------       -------       -------       -------
                ^                               |
                |                               |
                 -------------------------------
@end example

@noindent
It is generally a bad idea to create circular lists; if we need them: we should mimic an actually
circular chain of pointers with an iterator that ``wraps around''.

It is sometimes useful to crate a @dfn{tail--concatenated pair} or @dfn{tconc}; it structure is the
following, where the tconc is the first pair:

@example
 -------       -------       -------       -------
| A | D | --> | A | D | --> | A | D | --> | A | D |--> NULL
 -------       -------       -------       -------
  |                                         ^
  |                                         |
   -----------------------------------------
@end example

@noindent
the first word in the first pair holds a pointer to the last pair in the chain; when the list is
empty, the structure is:

@example
 -------
| A | D | --> NULL
 -------
  |
   --> NULL
@end example

It is sometimes useful to create an @dfn{association list} or @dfn{alist} as a simple key/value
structure; an alist has the following structure:

@example
 -------       -------       -------       -------
| A | D | --> | A | D | --> | A | D | --> | A | D | --> NULL
 -------       -------       -------       -------
  |             |             |             |
  v             v             v             v
 -------       -------       -------       -------
| A | D |     | A | D |     | A | D |     | A | D |
 -------       -------       -------       -------
  |   |         |   |         |   |         |   |
 key val       key val       key val       key val
@end example

@noindent
we find a value by performing a linear search for the corresponding key.  An empty alist is the
pointer @cnull{}.

@c page
@node init
@chapter Library initialisation


@deftypefun void ccpairs_library_init (void)
Initialise the internal structures of the library.  It is fine to call this function multiple times.

@quotation
@strong{NOTE} This function is defined with the @gcc{} attribute @code{constructor}, so, when the
library is built with @gcc{}: it will be called automatically by the library initialisation code.
@end quotation
@end deftypefun

@c page
@node version
@chapter Version functions


The installed libraries follow version numbering as established by the @gnu{} Autotools.  For an
explanation of interface numbers as managed by @gnu{} Libtool @xref{Libtool versioning, interface,
Libtool's versioning system, libtool, Shared library support for @gnu{}}.


@deftypefun {const char *} ccpairs_version_string (void)
Return a pointer to a statically allocated @asciiz{} string representing the interface version
number.
@end deftypefun


@deftypefun int ccpairs_version_interface_current (void)
Return an integer representing the library interface current number.
@end deftypefun


@deftypefun int ccpairs_version_interface_revision (void)
Return an integer representing the library interface current revision number.
@end deftypefun


@deftypefun int ccpairs_version_interface_age (void)
Return an integer representing the library interface current age.
@end deftypefun

@c page
@node typedefs
@chapter Some type definitions


@deftp {Integer Type} ccpairs_idx_t
Type of indexes used to reference pairs and items in lists.  It is an alias for @objtype{size_t}.
@end deftp


@deftp {Integer Type} ccpairs_len_t
Type of integers used to represent list lengths.  It is an alias for @objtype{size_t}.
@end deftp

@c page
@node pairs
@chapter Pair data structures


Pairs are meant to compose simply linked lists as follows:

@example
 -------
| A | D |
 -------
  |   |     -------
  v    --> | A | D |
value       -------
             |   |     -------
             v    --> | A | D |
           value       -------
                        |   |
                        v    --> NULL
                      value
@end example

@noindent
where both @var{A} and @var{D} are pointers; this picture represents the layout of a list of three
items.  Pairs are meant to be allocated on the heap, using a custom memory allocator.


@deftp {Struct Typedef} ccpairs_stru_t
Structure type representing a pair.  It is composed of two machine words.  From the point of view of
client code: @strong{pairs are immutable}.
@end deftp


@deftp {Pointer Typedef} ccpairs_t
@deftpx {Pointer Typedef} ccpair_t
Pointer types representing a pointer to @objtype{ccpairs_stru_t}.
@end deftp


@deftypefun uintptr_t ccpairs_car (ccpairs_t @var{P})
Return the first value in the pair as unsigned integer.  The first value in a pair is called an
@dfn{item}.
@end deftypefun


@deftypefun ccpairs_t ccpairs_cdr (ccpairs_t @var{P})
Return the second value in the pair as pointer to pair.
@end deftypefun


@deftypefun ccpairs_t ccpairs_car_pair (ccpairs_t @var{P})
Return the first value in the pair as pointer to pair.  This function is useful when the pair is a
node in a tree.
@end deftypefun


@deftypefun uintptr_t ccpairs_cdr_value (ccpairs_t @var{P})
Return the second value in the pair as unsigned integer.
@end deftypefun

@c page
@node memory
@chapter Memory allocation


@value{PACKAGE} uses the memory allocators @api{} defined by CCMemory; by default, it uses the
standard allocator @code{ccmem_standard_allocator}; @ccmemoryref{std, The standard allocator}.


@deftypefun {ccmem_allocator_t const *} ccpairs_register_allocator (ccmem_allocator_t const * @var{allocator})
Register a new custom allocator and return a pointer to the previous one.
@end deftypefun


All the following functions use the currently selected pair allocator.


@deftypefun ccpairs_t ccpairs_alloc (cce_location_t * @var{L})
Allocate a new pair structure and return a pointer to it.  If successful: return a pointer to the
new structure (this function never returns @cnull{}); otherwise raise an exception performing a
non--local exit to @var{L}.
@end deftypefun


@deftypefun void ccpairs_free (ccpairs_t @var{P})
Release the memory previously allocated for a pair with @cfunc{ccpairs_alloc}.  If @var{P} is
@cnull{}: nothing happens.
@end deftypefun


@deftypefun void ccpairs_free_list (ccpairs_t @var{P})
Release the memory previously allocated for a list of pairs with @cfunc{ccpairs_alloc}.  If @var{P}
is @cnull{}: nothing happens.

@quotation
@strong{NOTE} This function is @strong{unable} to correctly free circular lists.
@end quotation
@end deftypefun

@c page
@node ctors
@chapter Constructing pairs and lists


@menu
* ctors pairs::                 Pair constructors.
* ctors lists::                 List constructors.
@end menu

@c page
@node ctors pairs
@section Pair constructors


@menu
* ctors pairs plain::           Plain pair constructors.
* ctors pairs guarded::         Guarded pair constructors.
@end menu

@c page
@node ctors pairs plain
@subsection Plain pair constructors


@deftypefun ccpairs_t ccpairs_cons (cce_location_t * @var{L}, uintptr_t @var{A}, ccpairs_t @var{D})
Allocate a new pair using the currently selected memory allocator; initialise the first value with
@var{A} and the second value with @var{D}.  If successful: return a pointer to the new structure
(this function never returns @cnull{}); otherwise raise an exception performing a non--local exit to
@var{L}.

@example
cce_location_t  L[1]
ccpairs_t        P;

if (cce_location(L)) @{
  cce_run_catch_handlers_final(L);
@} else @{
  P = ccpairs_cons(L, 1, NULL);
  ...
  cce_run_body_handlers(L);
@}
@end example
@end deftypefun


@deftypefun ccpairs_t ccpairs_cons_improper (cce_location_t * @var{L}, uintptr_t @var{A}, uintptr_t @var{D})
Like @cfunc{ccpairs_cons} but accept a @code{uintptr_t} as second argument.

@example
cce_location_t  L[1]
ccpairs_t        P;

if (cce_location(L)) @{
  cce_run_catch_handlers_final(L);
@} else @{
  P = ccpairs_cons_improper(L, 1, 2);
  ...
  cce_run_body_handlers(L);
@}
@end example
@end deftypefun


@deftypefun ccpairs_t ccpairs_cons_node (cce_location_t * @var{L}, ccpairs_t @var{A}, ccpairs_t @var{D})
Like @cfunc{ccpairs_cons} but accept a @code{ccpairs_t} as first argument.

@example
cce_location_t  L[1]
ccpairs_t        P, Q;
cce_handler_t   P_H[1], Q_H[1];

if (cce_location(L)) @{
  cce_run_catch_handlers_final(L);
@} else @{
  Q = ccpairs_cons_node(L, 1, NULL);
  cce_error_handler_pair_init(L, Q_H, Q);

  P = ccpairs_cons_node(L, Q, NULL);

  ...
  cce_run_body_handlers(L);
@}
@end example
@end deftypefun

@c page
@node ctors pairs guarded
@subsection Guarded pair constructors


@menu
* ctors pairs guarded cons::    Guarded proper pair constructor.
* ctors pairs guarded icons::   Guarded improper pair constructor.
* ctors pairs guarded ncons::   Guarded node pair constructor.
@end menu

@c page
@node ctors pairs guarded cons
@subsubsection Proper guarded pair constructor


We can allocate a guarded pair as follows:

@smallexample
cce_location_t                L[1];
ccpairs_pair_clean_handler_t  H[1];

if (cce_location(L)) @{
  cce_run_catch_handlers_final(L);
@} else @{
  ccpairs_t  P = ccpairs_cons_guarded(L, H, 1, NULL);

  /* Do something with P here. */
  cce_run_body_handlers(L);
@}
@end smallexample


@deftypefun ccpairs_t ccpairs_cons_guarded_clean (cce_destination_t @var{L}, ccpairs_pair_clean_handler_t * @var{H}, uintptr_t @var{A}, ccpairs_t @var{D})
Allocate a new pair using the currently selected memory allocator; initialise the first value with
@var{A} and the second value with @var{D}.  When successful return a pointer to the new structure
(this function never returns @cnull{}); otherwise raise an exception performing a non--local exit to
@var{L}.

Associate the pair with the handler referenced by @var{H}; register the handler in the context of
the location @var{L}.
@end deftypefun


@deftypefun ccpairs_t ccpairs_cons_guarded_error (cce_destination_t @var{L}, ccpairs_pair_error_handler_t * @var{H}, uintptr_t @var{A}, ccpairs_t @var{D})
Allocate a new pair using the currently selected memory allocator; initialise the first value with
@var{A} and the second value with @var{D}.  When successful return a pointer to the new structure
(this function never returns @cnull{}); otherwise raise an exception performing a non--local exit to
@var{L}.

Associate the pair with the handler referenced by @var{H}; register the handler in the context of
the location @var{L}.
@end deftypefun


@deftypefn {Preprocessor Macro} ccpairs_t ccpairs_cons_guarded_error (cce_destination_t @var{L}, @var{H}, uintptr_t @var{A}, ccpairs_t @var{D})
If the type of @var{H} is:

@table @code
@item ccpairs_pair_clean_handler_t *
This macro use expands into a call to @cfunc{ccpairs_cons_guarded_clean}.

@item ccpairs_pair_error_handler_t *
This macro use expands into a call to @cfunc{ccpairs_cons_guarded_error}.
@end table
@end deftypefn

@c page
@node ctors pairs guarded icons
@subsubsection Improper guarded pair constructor


We can allocate a guarded improper pair as follows:

@smallexample
cce_location_t                L[1];
ccpairs_pair_clean_handler_t  H[1];

if (cce_location(L)) @{
  cce_run_catch_handlers_final(L);
@} else @{
  ccpairs_t  P = ccpairs_cons_improper_guarded(L, H, 1, 2);

  /* Do something with P here. */
  cce_run_body_handlers(L);
@}
@end smallexample


@deftypefun ccpairs_t ccpairs_cons_improper_guarded_clean (cce_destination_t @var{L}, ccpairs_pair_clean_handler_t * @var{H}, uintptr_t @var{A}, ccpairs_t @var{D})
Allocate a new pair using the currently selected memory allocator; initialise the first value with
@var{A} and the second value with @var{D}.  When successful return a pointer to the new structure
(this function never returns @cnull{}); otherwise raise an exception performing a non--local exit to
@var{L}.

Associate the pair with the handler referenced by @var{H}; register the handler in the context of
the location @var{L}.
@end deftypefun


@deftypefun ccpairs_t ccpairs_cons_improper_guarded_error (cce_destination_t @var{L}, ccpairs_pair_error_handler_t * @var{H}, uintptr_t @var{A}, ccpairs_t @var{D})
Allocate a new pair using the currently selected memory allocator; initialise the first value with
@var{A} and the second value with @var{D}.  When successful return a pointer to the new structure
(this function never returns @cnull{}); otherwise raise an exception performing a non--local exit to
@var{L}.

Associate the pair with the handler referenced by @var{H}; register the handler in the context of
the location @var{L}.
@end deftypefun


@deftypefn {Preprocessor Macro} ccpairs_t ccpairs_cons_improper_guarded_error (cce_destination_t @var{L}, @var{H}, uintptr_t @var{A}, ccpairs_t @var{D})
If the type of @var{H} is:

@table @code
@item ccpairs_pair_clean_handler_t *
This macro use expands into a call to @cfunc{ccpairs_cons_improper_guarded_clean}.

@item ccpairs_pair_error_handler_t *
This macro use expands into a call to @cfunc{ccpairs_cons_improper_guarded_error}.
@end table
@end deftypefn

@c page
@node ctors pairs guarded ncons
@subsubsection Guarded node pair constructor


We can allocate a guarded node pair as follows:

@smallexample
cce_location_t                L[1];
ccpairs_pair_clean_handler_t  P_H[1];
ccpairs_pair_clean_handler_t  Q_H[1];

if (cce_location(L)) @{
  cce_run_catch_handlers_final(L);
@} else @{
  ccpairs_t      P, Q;

  Q = ccpairs_cons_guarded(L, Q_H, 1, NULL);
  P = ccpairs_cons_node_guarded(L, P_H, Q, NULL);

  /* Do something with P here. */
  cce_run_body_handlers(L);
@}
@end smallexample


@deftypefun ccpairs_t ccpairs_cons_node_guarded_clean (cce_destination_t @var{L}, ccpairs_pair_clean_handler_t * @var{H}, uintptr_t @var{A}, ccpairs_t @var{D})
Allocate a new pair using the currently selected memory allocator; initialise the first value with
@var{A} and the second value with @var{D}.  When successful return a pointer to the new structure
(this function never returns @cnull{}); otherwise raise an exception performing a non--local exit to
@var{L}.

Associate the pair with the handler referenced by @var{H}; register the handler in the context of
the location @var{L}.
@end deftypefun


@deftypefun ccpairs_t ccpairs_cons_node_guarded_error (cce_destination_t @var{L}, ccpairs_pair_error_handler_t * @var{H}, uintptr_t @var{A}, ccpairs_t @var{D})
Allocate a new pair using the currently selected memory allocator; initialise the first value with
@var{A} and the second value with @var{D}.  When successful return a pointer to the new structure
(this function never returns @cnull{}); otherwise raise an exception performing a non--local exit to
@var{L}.

Associate the pair with the handler referenced by @var{H}; register the handler in the context of
the location @var{L}.
@end deftypefun


@deftypefn {Preprocessor Macro} ccpairs_t ccpairs_cons_node_guarded_error (cce_destination_t @var{L}, @var{H}, uintptr_t @var{A}, ccpairs_t @var{D})
If the type of @var{H} is:

@table @code
@item ccpairs_pair_clean_handler_t *
This macro use expands into a call to @cfunc{ccpairs_cons_node_guarded_clean}.

@item ccpairs_pair_error_handler_t *
This macro use expands into a call to @cfunc{ccpairs_cons_node_guarded_error}.
@end table
@end deftypefn

@c page
@node ctors lists
@section List constructors


@menu
* ctors lists plain::           Plain list constructors.
* ctors lists guarded::         Guarded list constructors.
@end menu

@c page
@node ctors lists plain
@subsection Plain list constructors


@deftypefun ccpairs_t ccpairs_list (cce_destination_t @var{L}, ccpairs_item_constructor_t * @var{ITEM_CTOR}, ccpairs_item_destructor_t * @var{ITEM_DTOR})
Build a new list filling it with items and return a pointer to the first pair.  If an error occurs:
raise an exception by performing a non--local exit to @var{L}.

New items are built with the constructor @var{ITEM_CTOR}, which receives as argument the index of
the item in the list, starting with zero.  When all the items meant to be in the list have been
built: the constructor must raise a break exception using the CCExceptions @api{} as follows:

@example
cce_raise(L, cce_condition_new_break());
@end example

If an error occurs while building the list: the pairs already allocated are released; the items
already built are released using the destructor @var{ITEM_DTOR}.
@end deftypefun

@c page
@node ctors lists guarded
@subsection Guarded list constructors


@deftypefun ccpairs_t ccpairs_list_guarded_clean (cce_destination_t @var{L}, ccpairs_list_item_clean_handler_t * @var{H}, ccpairs_item_constructor_t * @var{ITEM_CTOR}, ccpairs_item_destructor_t * @var{ITEM_DTOR})
Build a new list filling it with items and return a pointer to the first pair.  If an error occurs:
raise an exception by performing a non--local exit to @var{L}.

New items are built with the constructor @var{ITEM_CTOR}, which receives as argument the index of
the item in the list, starting with zero.  When all the items meant to be in the list have been
built: the constructor must raise a break exception using the CCExceptions @api{} as follows:

@example
cce_raise(L, cce_condition_new_break());
@end example

If an error occurs while building the list: the pairs already allocated are released; the items
already built are released using the destructor @var{ITEM_DTOR}.

Associate the pair with the handler referenced by @var{H}; register the handler in the context of
the location @var{L}.
@end deftypefun


@deftypefun ccpairs_t ccpairs_list_guarded_error (cce_destination_t @var{L}, ccpairs_list_item_error_handler_t * @var{H}, ccpairs_item_constructor_t * @var{ITEM_CTOR}, ccpairs_item_destructor_t * @var{ITEM_DTOR})
Build a new list filling it with items and return a pointer to the first pair.  If an error occurs:
raise an exception by performing a non--local exit to @var{L}.

New items are built with the constructor @var{ITEM_CTOR}, which receives as argument the index of
the item in the list, starting with zero.  When all the items meant to be in the list have been
built: the constructor must raise a break exception using the CCExceptions @api{} as follows:

@example
cce_raise(L, cce_condition_new_break());
@end example

If an error occurs while building the list: the pairs already allocated are released; the items
already built are released using the destructor @var{ITEM_DTOR}.

Associate the pair with the handler referenced by @var{H}; register the handler in the context of
the location @var{L}.
@end deftypefun


@deftypefn {Preprocessor Macro} ccpairs_t ccpairs_list_guarded (cce_destination_t @var{L}, @var{H}, ccpairs_item_constructor_t * @var{ITEM_CTOR}, ccpairs_item_destructor_t * @var{ITEM_DTOR})
If the type of @var{H} is:

@table @code
@item ccpairs_pair_clean_handler_t *
This macro use expands into a call to @cfunc{ccpairs_list_guarded_clean}.

@item ccpairs_pair_error_handler_t *
This macro use expands into a call to @cfunc{ccpairs_list_guarded_error}.
@end table
@end deftypefn

@c page
@node inspection
@chapter Inspecting lists


@deftypefun ccpairs_len_t ccpairs_length (cce_location_t @var{L}, ccpairs_t @var{P})
Return the number of pairs in the list beginning with @var{P}.  If @var{P} is @cnull{}: return zero.
If the operand is a circular list: raise an exception by performing a non--local exit to @var{L}.
@end deftypefun


@deftypefun bool ccpairs_is_empty (ccpairs_t @var{P})
@deftypefunx bool ccpairs_is_null (ccpairs_t @var{P})
Return @ctrue{} if @var{P} represents the empty list, that is: if @var{P} is @cnull{}.  Otherwise
return @cfalse{}.
@end deftypefun


@deftypefun bool ccpairs_is_last (ccpairs_t @var{P})
Return @ctrue{} if @var{P} is the last pair in its list, that is: if @var{P} is not @cnull{} and the
second item in @var{P} is @cnull{}.  Otherwise return @cfalse{}.
@end deftypefun


@deftypefun bool ccpairs_is_circular (ccpairs_t @var{P})
Return @ctrue{} if the list referenced by @var{P} is circular; otherwise return @cfalse{}.
@end deftypefun

@c page
@node accessors
@chapter Accessing items in lists


@menu
* accessors pairs::             Accessing list pairs.
* accessors items::             Accessing list items.
@end menu

@c page
@node accessors pairs
@section Accessing list pairs


@deftypefun ccpairs_t ccpairs_ref_pair (cce_location_t @var{L}, ccpairs_t @var{P}, ccpairs_idx_t @var{idx})
Return a pointer to the pair at the zero--based index @var{idx} in the list whose first pair is
@var{P}.  If the list length is less than or equal to @var{idx}: raise an exception by performing a
non--local exit to @var{L}.
@end deftypefun


@deftypefun ccpairs_t ccpairs_last_pair (cce_location_t * @var{L}, ccpairs_t @var{P})
Return a pointer to the last pair in the list @var{P}.  If @var{P} is @cnull{}: raise an exception
by performing a non--local exit to @var{L}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Numbered accessors


@deftypefun ccpairs_t ccpairs_first_pair (cce_location_t @var{L}, ccpairs_t @var{P})
Return the first pair in the list whose first pair is @var{P} (that is: return @var{P} itself).  If
the list is empty (that is: @var{P} is @cnull{}): raise an exception by performing a non--local exit
to @var{L}.
@end deftypefun


@deftypefun ccpairs_t ccpairs_second_pair (cce_location_t @var{L}, ccpairs_t @var{P})
Return the second pair in the list whose first pair is @var{P}.  If the list has less than two
pairs: raise an exception by performing a non--local exit to @var{L}.
@end deftypefun


@deftypefun ccpairs_t ccpairs_third_pair (cce_location_t @var{L}, ccpairs_t @var{P})
Return the third pair in the list whose first pair is @var{P}.  If the list has less than three
pairs: raise an exception by performing a non--local exit to @var{L}.
@end deftypefun


@deftypefun ccpairs_t ccpairs_fourth_pair (cce_location_t @var{L}, ccpairs_t @var{P})
Return the fourth pair in the list whose first pair is @var{P}.  If the list has less than four
pairs: raise an exception by performing a non--local exit to @var{L}.
@end deftypefun


@deftypefun ccpairs_t ccpairs_fifth_pair (cce_location_t @var{L}, ccpairs_t @var{P})
Return the fifth pair in the list whose first pair is @var{P}.  If the list has less than five
pairs: raise an exception by performing a non--local exit to @var{L}.
@end deftypefun


@deftypefun ccpairs_t ccpairs_sixth_pair (cce_location_t @var{L}, ccpairs_t @var{P})
Return the sixth pair in the list whose first pair is @var{P}.  If the list has less than six pairs:
raise an exception by performing a non--local exit to @var{L}.
@end deftypefun


@deftypefun ccpairs_t ccpairs_seventh_pair (cce_location_t @var{L}, ccpairs_t @var{P})
Return the seventh pair in the list whose first pair is @var{P}.  If the list has less than seven
pairs: raise an exception by performing a non--local exit to @var{L}.
@end deftypefun


@deftypefun ccpairs_t ccpairs_eighth_pair (cce_location_t @var{L}, ccpairs_t @var{P})
Return the eighth pair in the list whose first pair is @var{P}.  If the list has less than eigth
pairs: raise an exception by performing a non--local exit to @var{L}.
@end deftypefun


@deftypefun ccpairs_t ccpairs_nineth_pair (cce_location_t @var{L}, ccpairs_t @var{P})
Return the nineth pair in the list whose first pair is @var{P}.  If the list has less than nine
pairs: raise an exception by performing a non--local exit to @var{L}.
@end deftypefun


@deftypefun ccpairs_t ccpairs_tenth_pair (cce_location_t @var{L}, ccpairs_t @var{P})
Return the tenth pair in the list whose first pair is @var{P}.  If the list has less than ten pairs:
raise an exception by performing a non--local exit to @var{L}.
@end deftypefun

@c page
@node accessors items
@section Accessing list items


@deftypefun uintptr_t ccpairs_ref (cce_location_t @var{L}, ccpairs_t @var{P}, ccpairs_idx_t @var{idx})
Return the item at the zero--based index @var{idx} in the list whose first pair is @var{P}.  If the
list length is less than or equal to @var{idx}: raise an exception by performing a non--local exit
to @var{L}.
@end deftypefun


@deftypefun uintptr_t ccpairs_pair (cce_location_t * @var{L}, ccpairs_t @var{P})
Return the item of the last pair in the list @var{P}.  If @var{P} is @cnull{}: raise an exception by
performing a non--local exit to @var{L}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Numbered accessors


@deftypefun uintptr_t ccpairs_first (cce_location_t @var{L}, ccpairs_t @var{P})
Return the first item in the list whose first pair is @var{P}.  If the list is empty (that is:
@var{P} is @cnull{}): raise an exception by performing a non--local exit to @var{L}.
@end deftypefun


@deftypefun uintptr_t ccpairs_second (cce_location_t @var{L}, ccpairs_t @var{P})
Return the second item in the list whose first pair is @var{P}.  If the list has less than two
pairs: raise an exception by performing a non--local exit to @var{L}.
@end deftypefun


@deftypefun uintptr_t ccpairs_third (cce_location_t @var{L}, ccpairs_t @var{P})
Return the third item in the list whose first pair is @var{P}.  If the list has less than three
pairs: raise an exception by performing a non--local exit to @var{L}.
@end deftypefun


@deftypefun uintptr_t ccpairs_fourth (cce_location_t @var{L}, ccpairs_t @var{P})
Return the fourth item in the list whose first pair is @var{P}.  If the list has less than four
pairs: raise an exception by performing a non--local exit to @var{L}.
@end deftypefun


@deftypefun uintptr_t ccpairs_fifth (cce_location_t @var{L}, ccpairs_t @var{P})
Return the fifth item in the list whose first pair is @var{P}.  If the list has less than five
pairs: raise an exception by performing a non--local exit to @var{L}.
@end deftypefun


@deftypefun uintptr_t ccpairs_sixth (cce_location_t @var{L}, ccpairs_t @var{P})
Return the sixth item in the list whose first pair is @var{P}.  If the list has less than six pairs:
raise an exception by performing a non--local exit to @var{L}.
@end deftypefun


@deftypefun uintptr_t ccpairs_seventh (cce_location_t @var{L}, ccpairs_t @var{P})
Return the seventh item in the list whose first pair is @var{P}.  If the list has less than seven
pairs: raise an exception by performing a non--local exit to @var{L}.
@end deftypefun


@deftypefun uintptr_t ccpairs_eighth (cce_location_t @var{L}, ccpairs_t @var{P})
Return the eighth item in the list whose first pair is @var{P}.  If the list has less than eigth
pairs: raise an exception by performing a non--local exit to @var{L}.
@end deftypefun


@deftypefun uintptr_t ccpairs_nineth (cce_location_t @var{L}, ccpairs_t @var{P})
Return the nineth item in the list whose first pair is @var{P}.  If the list has less than nine
pairs: raise an exception by performing a non--local exit to @var{L}.
@end deftypefun


@deftypefun uintptr_t ccpairs_tenth (cce_location_t @var{L}, ccpairs_t @var{P})
Return the tenth item in the list whose first pair is @var{P}.  If the list has less than ten pairs:
raise an exception by performing a non--local exit to @var{L}.
@end deftypefun

@c page
@node conditions
@chapter Exceptional condition objects


@value{PACKAGE} uses the external library CCExceptions to signal exceptional conditions and errors
through non--local exits; @xref{Top, CCExceptions, CCExceptions, ccexceptions, CCExceptions}.

The functions will raise exceptional conditions with @cfunc{cce_raise} and expect the caller to
intercept them using the @code{cce_location_t} mechanics.  The basic code template is:

@example
#include <ccpair.h>

cce_location_t  L[1];

if (cce_location(L)) @{
  /* Handle errors here. */
  cce_run_catch_handlers_final(L);
@} else @{
  /* Do something useful here. */
  cce_run_body_handlers(L);
@}
@end example

@menu
* conditions not-enough::       Not enough items in list.
* conditions empty::            Invalid empty list as operand.
* conditions circular::         Invalid circular list as operand.
@end menu

@c page
@node conditions not-enough
@section Not enough items in list


@cindex Not enough items in list, exceptional condition
@cindex Exceptional conditions, not enough items in list


@deftp {Struct Typedef} ccpairs_descriptor_not_enough_items_t
Type of data structure representing the exceptional--condition descriptor for the error: not enough
items in list.  It has the following public fields:

@table @code
@item cce_descriptor_t descriptor
The condition descriptor's base values.
@end table

The parent of this type descriptor is the one referenced by @code{cce_descriptor_logic_error_ptr};
@xref{conditions logic error, CCExceptions, CCExceptions, ccexceptions, CCExceptions}.
@end deftp


@deftp {Struct Typedef} ccpairs_condition_not_enough_items_t
Type of data structure representing the exceptional--condition object for the error: not enough
items in list.  It has the following public fields:

@table @code
@item cce_condition_t base
The condition object's base values.
@end table
@end deftp


@deftypevr {Dynamic Constant} {const ccpairs_descriptor_not_enough_items_t * const} ccpairs_descriptor_not_enough_items
Pointer to a statically allocated exceptional condition descriptor.
@end deftypevr


@deftypefun {cce_condition_t const *} ccpairs_condition_new_not_enough_items (void)
Return a pointer to exceptional condition object.
@end deftypefun


@deftypefun bool ccpairs_condition_is_not_enough_items (cce_condition_t const * @var{C})
Return @ctrue{} if @var{C} if of type @code{ccpairs_descriptor_not_enough_items}; otherwise return
@cfalse{}.
@end deftypefun


To catch this exceptional condition we can do:

@example
cce_location_t        L[1];

if (cce_location(L)) @{
  if (ccpairs_condition_is_not_enough_items(cce_condition(L))) @{
    ccpairs_condition_not_enough_items_t * C = \
      (ccpairs_condition_not_enough_items_t *) cce_condition(L);
    do_something_with(C);
  @}
  cce_run_catch_handlers_final(L);
@} else @{
  do_something(L);
  cce_run_body_handlers(L);
@}
@end example

@c page
@node conditions empty
@section Invalid empty list as operand


@cindex Invalid empty list as operand, exceptional condition
@cindex Exceptional conditions, Invalid empty list as operand


@deftp {Struct Typedef} ccpairs_descriptor_empty_list_t
Type of data structure representing the exceptional--condition descriptor for the error: invalid
empty list as operand.  It has the following public fields:

@table @code
@item cce_descriptor_t descriptor
The condition descriptor's base values.
@end table

The parent of this type descriptor is the one referenced by
@code{ccpairs_descriptor_not_enough_items}.
@end deftp


@deftp {Struct Typedef} ccpairs_condition_empty_list_t
Type of data structure representing the exceptional--condition object for the error: invalid empty
list as operand.  It has the following public fields:

@table @code
@item cce_condition_t base
The condition object's base values.
@end table
@end deftp


@deftypevr {Dynamic Constant} {const ccpairs_descriptor_empty_list_t * const} ccpairs_descriptor_empty_list
Pointer to a statically allocated exceptional condition descriptor.
@end deftypevr


@deftypefun {cce_condition_t const *} ccpairs_condition_new_empty_list (void)
Return a pointer to exceptional condition object.
@end deftypefun


@deftypefun bool ccpairs_condition_is_empty_list (cce_condition_t const * @var{C})
Return @ctrue{} if @var{C} if of type @code{ccpairs_descriptor_empty_list}; otherwise return
@cfalse{}.
@end deftypefun


To catch this exceptional condition we can do:

@example
cce_location_t        L[1];

if (cce_location(L)) @{
  if (ccpairs_condition_is_empty_list(cce_condition(L))) @{
    ccpairs_condition_empty_list_t * C = \
      (ccpairs_condition_empty_list_t *) cce_condition(L);
    do_something_with(C);
  @}
  cce_run_catch_handlers_final(L);
@} else @{
  do_something(L);
  cce_run_body_handlers(L);
@}
@end example

@c page
@node conditions circular
@section Invalid circular list as operand


@cindex Invalid circular list as operand, exceptional condition
@cindex Exceptional conditions, Invalid circular list as operand


@deftp {Struct Typedef} ccpairs_descriptor_circular_list_t
Type of data structure representing the exceptional--condition descriptor for the error: invalid
circular list as operand.  It has the following public fields:

@table @code
@item cce_descriptor_t descriptor
The condition descriptor's base values.
@end table

The parent of this type descriptor is the one referenced by @code{cce_descriptor_logic_error_ptr};
@xref{conditions logic error, CCExceptions, CCExceptions, ccexceptions, CCExceptions}.
@end deftp


@deftp {Struct Typedef} ccpairs_condition_circular_list_t
Type of data structure representing the exceptional--condition object for the error: invalid
circular list as operand.  It has the following public fields:

@table @code
@item cce_condition_t base
The condition object's base values.
@end table
@end deftp


@deftypevr {Dynamic Constant} {const ccpairs_descriptor_circular_list_t * const} ccpairs_descriptor_circular_list
Pointer to a statically allocated exceptional condition descriptor.
@end deftypevr


@deftypefun {cce_condition_t const *} ccpairs_condition_new_circular_list (void)
Return a pointer to exceptional condition object.
@end deftypefun


@deftypefun bool ccpairs_condition_is_circular_list (cce_condition_t const * @var{C})
Return @ctrue{} if @var{C} if of type @code{ccpairs_descriptor_circular_list}; otherwise return
@cfalse{}.
@end deftypefun


To catch this exceptional condition we can do:

@example
cce_location_t        L[1];

if (cce_location(L)) @{
  if (ccpairs_condition_is_circular_list(cce_condition(L))) @{
    ccpairs_condition_circular_list_t * C = \
      (ccpairs_condition_circular_list_t *) cce_condition(L);
    do_something_with(C);
  @}
  cce_run_catch_handlers_final(L);
@} else @{
  do_something(L);
  cce_run_body_handlers(L);
@}
@end example

@c page
@node handlers
@chapter Exceptional condition handlers


@menu
* handlers pairs::              Handler for pair release.
* handlers lists::              Handler for list release.
* handlers items::              Handler for item release.
* handlers itpairs::            Handler for pair-and-item release.
* handlers itlists::            Handler for list-and-items release.
@end menu

@c page
@node handlers pairs
@section Handler for pair release


We can handle pairs that must be released with the function @cfunc{ccpairs_free} as follows:

@example
cce_location_t                L[1];
ccpairs_pair_clean_handler_t  H[1];

if (ccpairs_location(L)) @{
  cce_run_catch_handlers_final(L);
@} else @{
  ccpairs_t  P = ccpairs_cons(1, NULL);
  ccpairs_init_and_register_pair_handler(L, H, P);

  /* Do something with P here. */
  cce_run_body_handlers(L);
@}
@end example

The following symbols are defined in the header file @file{ccpairs.h}.


@deftp {Struct Typedef} ccpairs_pair_clean_handler_t
@deftpx {Struct Typedef} ccpairs_pair_error_handler_t
Type of structures representing exception handlers for pairs without item destructor.
@end deftp


@deftypefun void ccpairs_init_and_register_pair_clean_handler (cce_destination_t @var{L}, ccpairs_pair_clean_handler_t * @var{H}, ccpairs_t @var{P})
Initialise the exception handler referenced by @var{H} to delete the pair referenced by @var{P};
register the handler in the context of the location @var{L}.
@end deftypefun


@deftypefun void ccpairs_init_and_register_pair_error_handler (cce_destination_t @var{L}, ccpairs_pair_error_handler_t * @var{H}, ccpairs_t @var{P})
Initialise the exception handler referenced by @var{H} to delete the pair referenced by @var{P};
register the handler in the context of the location @var{L}.
@end deftypefun


@deftypefn {Preprocessor Macro} void ccpairs_init_and_register_pair_handler (cce_destination_t @var{L}, @var{H}, ccpairs_t @var{P})
Initialise the exception handler referenced by @var{H} to delete the pair referenced by @var{P};
register the handler in the context of the location @var{L}.  If the type of the pointer @var{H} is.

@table @code
@item ccpairs_pair_clean_handler_t *
The macro use expands into a call to @cfunc{ccpairs_init_and_register_pair_clean_handler}.

@item ccpairs_pair_error_handler_t *
The macro use expands into a call to @cfunc{ccpairs_init_and_register_pair_error_handler}.
@end table
@end deftypefn

@c page
@node handlers lists
@section Handler for list release


We can handle lists that must be released with the function @cfunc{ccpairs_free_list} as follows:

@example
cce_location_t                L[1];
ccpairs_list_clean_handler_t  H[1];

if (ccpairs_location(L)) @{
  cce_run_catch_handlers_final(L);
@} else @{
  ccpairs_t P = ccpairs_cons(1, ccpairs_cons(2, NULL));
  ccpairs_init_and_register_list_handler(L, H, P);

  /* Do something with P here. */
  cce_run_body_handlers(L);
@}
@end example

The following symbols are defined in the header file @file{ccpairs.h}.


@deftp {Struct Typedef} ccpairs_list_clean_handler_t
@deftpx {Struct Typedef} ccpairs_list_error_handler_t
Type of structures representing exception handlers for lists without item destructor.
@end deftp


@deftypefun void ccpairs_init_and_register_list_clean_handler (cce_destination_t @var{L}, ccpairs_list_clean_handler_t * @var{H}, ccpairs_t @var{P})
Initialise the exception handler referenced by @var{H} to delete the list referenced by @var{P};
register the handler in the context of the location @var{L}.
@end deftypefun


@deftypefun void ccpairs_init_and_register_list_error_handler (cce_destination_t @var{L}, ccpairs_list_error_handler_t * @var{H}, ccpairs_t @var{P})
Initialise the exception handler referenced by @var{H} to delete the list referenced by @var{P};
register the handler in the context of the location @var{L}.
@end deftypefun


@deftypefn {Preprocessor Macro} void ccpairs_init_and_register_list_handler (cce_destination_t @var{L}, @var{H}, ccpairs_t @var{P})
Initialise the exception handler referenced by @var{H} to delete the list referenced by @var{P};
register the handler in the context of the location @var{L}.  If the type of the pointer @var{H} is.

@table @code
@item ccpairs_list_clean_handler_t *
The macro use expands into a call to @cfunc{ccpairs_init_and_register_list_clean_handler}.

@item ccpairs_list_error_handler_t *
The macro use expands into a call to @cfunc{ccpairs_init_and_register_list_error_handler}.
@end table
@end deftypefn

@c page
@node handlers items
@section Handler for item release


We might want to build an item object and then store it into a pair or list; if an error occurs we
want to release such item; the handlers defined by @value{PACKAGE} allow us to do so using the
location mechanism.  Here is an example of item and pair construction:

@smallexample
uintptr_t
item_constructor (cce_destination_t L)
@{
  /* Build and return an item. */
@}

void
item_destructor (uintptr_t item)
@{
  /* Release an item. */
@}

int
main (void)
@{
  cce_location_t                L[1];
  ccpairs_pair_clean_handler_t  pair_H[1];
  ccpairs_item_error_handler_t  item_H[1];

  if (ccpairs_location(L)) @{
    cce_run_catch_handlers_final(L);
  @} else @{
    uintptr_t  item;
    ccpairs_t  P;

    item = item_constructor(L);
    ccpairs_init_and_register_item_handler(L, item_H, item, item_destructor);

    /* Do something here, possibly raising an exception. */

    P = ccpairs_cons(item, NULL);
    ccpairs_init_and_register_pair_item_handler(L, pair_H, P, item_destructor);

    /* Do something with P here. */
    cce_run_body_handlers(L);
  @}

  return 0;
@}
@end smallexample

The following symbols are defined in the header file @file{ccpairs.h}.


@deftp {Struct Typedef} ccpairs_item_clean_handler_t
@deftpx {Struct Typedef} ccpairs_item_error_handler_t
Type of structures representing exception handlers for items.
@end deftp


@deftypefun void ccpairs_init_and_register_item_clean_handler (cce_destination_t @var{L}, ccpairs_item_clean_handler_t * @var{H}, uintptr_t @var{ITEM}, ccpairs_item_destructor_t * @var{DESTRUCTOR})
Initialise the exception handler referenced by @var{H} to delete the item referenced by @var{ITEM},
using the destructor referenced by @var{DESTRUCTOR}; register the handler in the context of the
location @var{L}.
@end deftypefun


@deftypefun void ccpairs_init_and_register_item_error_handler (cce_destination_t @var{L}, ccpairs_item_error_handler_t * @var{H}, uintptr_t @var{ITEM}, ccpairs_item_destructor_t * @var{DESTRUCTOR})
Initialise the exception handler referenced by @var{H} to delete the item referenced by @var{ITEM},
using the destructor referenced by @var{DESTRUCTOR}; register the handler in the context of the
location @var{L}.
@end deftypefun


@deftypefn {Preprocessor Macro} void ccpairs_init_and_register_item_handler (cce_destination_t @var{L}, @var{H}, uintptr_t @var{ITEM}, ccpairs_item_destructor_t * @var{DESTRUCTOR})
Initialise the exception handler referenced by @var{H} to delete the item referenced by @var{ITEM},
using the destructor referenced by @var{DESTRUCTOR}; register the handler in the context of the
location @var{L}.  If the type of the pointer @var{H} is.

@table @code
@item ccpairs_item_clean_handler_t *
The macro use expands into a call to @cfunc{ccpairs_init_and_register_item_clean_handler}.

@item ccpairs_item_error_handler_t *
The macro use expands into a call to @cfunc{ccpairs_init_and_register_item_error_handler}.
@end table
@end deftypefn

@c page
@node handlers itpairs
@section Handler for pair--and--item release


We might want to build an item object and then store it into a pair; if an error occurs we want to
release such item; after the item has been put into a pair we may want to release the pair and the
item together using a specialised item destructor; the handlers defined by @value{PACKAGE} allow us
to do so using the exceptions mechanism.  We must be careful in separating the two moments: item
construction then pair construction; pair--and--item destruction.

Here is an example of item and pair construction:

@example
uintptr_t
item_constructor (cce_destination_t L)
@{
  /* Build and return an item. */
@}

void
item_destructor (uintptr_t item)
@{
  /* Release an item. */
@}

void
main (void)
@{
  ccpairs_t  P;

  /* Build the item and the pair.  Upon exiting this block: we release
     the item only if an error has occurred. */
  @{
    cce_location_t                L[1];
    ccpairs_pair_error_handler_t  pair_H[1];
    ccpairs_item_error_handler_t  item_H[1];

    if (ccpairs_location(L)) @{
      cce_run_catch_handlers_final(L);
      exit(EXIT_FAILURE);
    @} else @{
      uintptr_t  item;
      ccpairs_t  P;

      item = item_constructor(L);
      ccpairs_init_and_register_item_handler(L, item_H, item, item_destructor);

      P = ccpairs_cons(item, NULL);
      ccpairs_init_and_register_pair_item_handler(L, pair_H, P, item_destructor);

      /* Maybe do something with P here, possibly raising and exception. */
      cce_run_body_handlers(L);
    @}
  @}

  /* Now use the pair and finally release both the pair and the item. */
  @{
    cce_location_t                     L[1];
    ccpairs_pair_item_clean_handler_t  pair_H[1];

    if (ccpairs_location(L)) @{
      cce_run_catch_handlers_final(L);
      exit(EXIT_FAILURE);
    @} else @{
      ccpairs_init_and_register_pair_item_handler(L, pair_H, P, item_destructor);
      /* Do something with P here. */
      cce_run_body_handlers(L);
    @}
  @}

  exit(EXIT_SUCCESS);
@}
@end example

The following symbols are defined in the header file @file{ccpairs.h}.


@deftp {Struct Typedef} ccpairs_pair_item_clean_handler_t
@deftpx {Struct Typedef} ccpairs_pair_item_error_handler_t
Type of structures representing exception handlers for pairs holding items with destructor.
@end deftp


@deftypefun void ccpairs_init_and_register_pair_item_clean_handler (cce_destination_t @var{L}, ccpairs_pair_item_clean_handler_t * @var{H}, ccpairs_t @var{P}, ccpairs_pair_item_destructor_t * @var{DESTRUCTOR})
Initialise the exception handler referenced by @var{H} to delete the list referenced by @var{P},
using the destructor referenced by @var{DESTRUCTOR} to delete the item; register the handler in the
context of the location @var{L}.
@end deftypefun


@deftypefun void ccpairs_init_and_register_pair_item_error_handler (cce_destination_t @var{L}, ccpairs_pair_item_error_handler_t * @var{H}, ccpairs_t @var{P}, ccpairs_pair_item_destructor_t * @var{DESTRUCTOR})
Initialise the exception handler referenced by @var{H} to delete the list referenced by @var{P},
using the destructor referenced by @var{DESTRUCTOR} to delete the item; register the handler in the
context of the location @var{L}.
@end deftypefun


@deftypefn {Preprocessor Macro} void ccpairs_init_and_register_pair_item_handler (cce_destination_t @var{L}, @var{H}, ccpairs_t @var{P}, ccpairs_pair_item_destructor_t * @var{DESTRUCTOR})
Initialise the exception handler referenced by @var{H} to delete the list referenced by @var{P},
using the destructor referenced by @var{DESTRUCTOR} to delete the item; register the handler in the
context of the location @var{L}.  If the type of the pointer @var{H} is.

@table @code
@item ccpairs_pair_item_clean_handler_t *
The macro use expands into a call to @cfunc{ccpairs_init_and_register_pair_item_clean_handler}.

@item ccpairs_pair_item_error_handler_t *
The macro use expands into a call to @cfunc{ccpairs_init_and_register_pair_item_error_handler}.
@end table
@end deftypefn

@c page
@node handlers itlists
@section Handler for list--and--items release


We might want to build an item object and then store it into a list; if an error occurs we want to
release such item; after the item has been put into a list we may want to release the list and the
item together using a specialised item destructor; the handlers defined by @value{PACKAGE} allow us
to do so using the exceptions mechanism.  We must be careful in separating the two moments: item
construction then list construction; list--and--item destruction.

Here is an example of item and list construction:

@example
uintptr_t
item_constructor (cce_destination_t L)
@{
  /* Build and return an item. */
@}

void
item_destructor (uintptr_t item)
@{
  /* Release an item. */
@}

void
main (void)
@{
  ccpairs_t  P;

  /* Build the item and the list.  Upon exiting this block: we release
     the item only if an error has occurred. */
  @{
    cce_location_t                L[1];
    ccpairs_pair_error_handler_t  pair_Q_H[1];
    ccpairs_list_error_handler_t  list_P_H[1];
    ccpairs_item_error_handler_t  item_P_H[1], item_Q_H[1];

    if (ccpairs_location(L)) @{
      cce_run_catch_handlers_final(L);
      exit(EXIT_FAILURE);
    @} else @{
      uintptr_t  item_P, item_Q;
      ccpairs_t  P, Q;

      item_P = item_constructor(L);
      ccpairs_init_and_register_item_handler(L, item_P_H, item_P, item_destructor);

      item_Q = item_constructor(L);
      ccpairs_init_and_register_item_handler(L, item_Q_H, item_Q, item_destructor);

      Q = ccpairs_cons(item_Q, NULL);
      ccpairs_init_and_register_list_item_handler(L, pair_Q_H, Q, item_destructor);

      P = ccpairs_cons(item_P, Q);
      ccpairs_init_and_register_list_item_handler(L, list_P_H, P, item_destructor);

      /* Maybe do something with P here, possibly raising and exception. */
      cce_run_body_handlers(L);
    @}
  @}

  /* Now use the list and finally release both the list and the item. */
  @{
    cce_location_t                     L[1];
    ccpairs_list_item_clean_handler_t  list_H[1];

    if (ccpairs_location(L)) @{
      cce_run_catch_handlers_final(L);
      exit(EXIT_FAILURE);
    @} else @{
      ccpairs_init_and_register_list_item_handler(L, list_H, P, item_destructor);
      /* Do something with P here. */
      cce_run_body_handlers(L);
    @}
  @}

  exit(EXIT_SUCCESS);
@}
@end example

The following symbols are defined in the header file @file{ccpairs.h}.


@deftp {Struct Typedef} ccpairs_list_item_clean_handler_t
@deftpx {Struct Typedef} ccpairs_list_item_error_handler_t
Type of structures representing exception handlers for lists holding items with destructor.
@end deftp


@deftypefun void ccpairs_init_and_register_list_item_clean_handler (cce_destination_t @var{L}, ccpairs_list_item_clean_handler_t * @var{H}, ccpairs_t @var{P}, ccpairs_list_item_destructor_t * @var{DESTRUCTOR})
Initialise the exception handler referenced by @var{H} to delete the list referenced by @var{P},
using the destructor referenced by @var{DESTRUCTOR} to delete the item; register the handler in the
context of the location @var{L}.
@end deftypefun


@deftypefun void ccpairs_init_and_register_list_item_error_handler (cce_destination_t @var{L}, ccpairs_list_item_error_handler_t * @var{H}, ccpairs_t @var{P}, ccpairs_list_item_destructor_t * @var{DESTRUCTOR})
Initialise the exception handler referenced by @var{H} to delete the list referenced by @var{P},
using the destructor referenced by @var{DESTRUCTOR} to delete the item; register the handler in the
context of the location @var{L}.
@end deftypefun


@deftypefn {Preprocessor Macro} void ccpairs_init_and_register_list_item_handler (cce_destination_t @var{L}, @var{H}, ccpairs_t @var{P}, ccpairs_list_item_destructor_t * @var{DESTRUCTOR})
Initialise the exception handler referenced by @var{H} to delete the list referenced by @var{P},
using the destructor referenced by @var{DESTRUCTOR} to delete the item; register the handler in the
context of the location @var{L}.  If the type of the pointer @var{H} is.

@table @code
@item ccpairs_list_item_clean_handler_t *
The macro use expands into a call to @cfunc{ccpairs_init_and_register_list_item_clean_handler}.

@item ccpairs_list_item_error_handler_t *
The macro use expands into a call to @cfunc{ccpairs_init_and_register_list_item_error_handler}.
@end table
@end deftypefn

@c page
@node utils
@chapter Utility definitions


@defmac CCPAIRS_PC (@var{POINTER_TYPE}, @var{POINTER_NAME}, @var{EXPRESSION})
Preprocessor macro used to define pointer variables initialised with a cast expression.  It expands
to:

@example
POINTER_TYPE * POINTER_NAME = (POINTER_TYPE *) (EXPRESSION)
@end example

For example, the macro use:

@example
CCPAIRS_PC(ccpairs_descriptor_error_t, C, _C);
@end example

@noindent
expands into:

@example
ccpairs_descriptor_error_t * C = \
   (ccpairs_descriptor_error_t *) (_C);
@end example
@end defmac


@defmac CCPAIRS_UNUSED
Preprocessor macro that is meant to expand into an attribute declaration.  If the symbol
@code{__GNUC__} is defined, the expansion is:

@example
__attribute__((__unused__))
@end example

@noindent
otherwise the expansion is the empty string.
@end defmac

@c page
@c ------------------------------------------------------------
@c Appendices.
@c ------------------------------------------------------------

@include lgpl-3.0.texi
@include fdl-1.3.texi

@c page
@node references
@appendix Bibliography and references


The documentation of @value{PACKAGE} is available online:

@center @value{DocumentationUrl}

@noindent
the latest release of this package can be downloaded from:

@center @value{DownloadUrl}

@noindent
development takes place at:

@center @value{GithubUrl}

@noindent
and as backup at:

@center @value{BitbucketUrl}

@noindent
the package CCExceptions is available at:

@center @url{https://github.com/marcomaggi/ccexceptions/}

@noindent
the package CCMemory is available at:

@center @url{https://github.com/marcomaggi/ccmemory/}

@noindent
the package CCStructs is available at:

@center @url{https://github.com/marcomaggi/ccstructs/}

@noindent
the package CCTests is available at:

@center @url{https://github.com/marcomaggi/cctests/}

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file

